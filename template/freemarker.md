# 模板开发指南
## 入门
### 模板+数据模型=输出
### 数据模型一览
### 模板一览
## 数值，类型
### 基本内容
### 类型
## 模板
### 总体结构
### 指令
### 表达式
### 插值
## 其他
### 自定义指令
### 在模板中定义变凉
### 命名空间
### 替换(方括号)语法
# 程序开发指南
## 入门
### 创建Configuration实例
### 创建数据模型
### 获取模版
### 合并模板语数据模型
### 将代码放在一起
## 数据模型
### 基本内容
### 标量
### 容器
### 方法
### 指令
### 结点变量
### 对象包装
## 配置
### 基本内容
### 共享变量
### 配置设置
### 模板加载
### 错误控制
### 不兼容改进设置
## 其他
### 变量，范围
当调用Template.process方法时，它会在方法内部创建一个Environment对象，在process返回之前一直使用，该对象存储模板执行时的运行状态信息。除了这些，他还会存储有模板中指令，如assign、macro、local、global创建的变量，它不会尝试修改传递给process的数据模型对象，也不会创建或替换存储在配置中的共享变量。FreeMarker查找变量的优先级如下:
- Environment变量
  - 如果在循环中，在循环变量的集合中，循环变量由list指令等创建;
  - 如果在macro中，在macro的局部变量集合中，局部变量可以由local指令创建，而且，宏的参数也是局部变量;
  - 在当前的命名空间中，可以使用assign指令将变量放到一个命名空间中;
  - 在由global指令创建的变量集合中。FTL将它们视为数据模型的普通成员变量一样来控制它们。也就是说，它们在所有的命名空间中都可见，
    你也可以像访问一个数据模型中的数据一样来访问它们。
- 传递给process方法的数据模型对象
- Configuration对象存储的共享变量集合
  
在实际操作中，来自模板设计者的观点是这6种情况应该只有4种，因为从那种观点来看，后面3种(由global创建的变量，真实的数据模型对象，共享变量)共同构成了全局变量的集合。
### 字符集问题
### 多线程
在多线程运行环境中，Configuration实例，Template实例和数据模型应该是永远不能改变(只读)的对象。也就是说，创建和初始化它们(如使用set等方法)之后，就不能再修改它们了(比如不能再次调用set等修改方法)。这就允许我们在多线程环境中避免代价很大的同步锁问题。要小心Template实例；当使用了Configuration.getTemplate方法获得Template一个实例时，也许得到的是从模板缓存中缓存的实例，这些实例都已经被其他线程使用了，所以不要调用它们的set方法(当然调用process方法还是不错的)。如果只从同一个独立线程中访问所有对象，那么上面所述的限制将不会起作用。使用FTL来修改数据模型对象或者共享变量是不太可能的，除非将方法(或其他对象)放到数据模型中来做。我们不鼓励你编写修改数据模型对象或共享变量的方法。多试试使用存储在环境对象(这个对象是为独立的Template.process调用而创建的，用来存储模板处理的运行状态)中的变量，所以最好不要修改那些由多线程使用的数据。要获取更多信息，请阅读：变量，范围。
### Bean的包装
### 日志
### 在Servlet中使用FreeMarker
### 为FreeMarker配置安全策略
### 遗留的XML包装实现
### 和Ant一起使用FreeMarker
### Jython包装器
# 模板语言参考
## 内建函数参考
## 指令参考
## 特殊变量参考
## FTL中的保留名称
## 废弃的FTL结构
# XML处理指南
## 前言
## 揭示XML文档
## 必要的XML处理
## 声明的XML处理

<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>&#x8bbf;&#x95ee;&#x547d;&#x4ee4;&#x884c;&#x53c2;&#x6570;&#x7684;&#x5c5e;&#x6027;&#x6e90;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <p>[TOC]</p>
<ul>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%BA%90">访问命令行参数的属性源</a></li>
<li><a href="#json%E5%B1%9E%E6%80%A7">JSON属性</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%9E%E6%80%A7">外部的应用属性</a>
<ul>
<li><a href="#optional-locations">Optional Locations</a></li>
<li><a href="#wildcard-locations">Wildcard Locations</a></li>
<li><a href="#profile-specific-files">Profile Specific Files</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%95%B0%E6%8D%AE">导入额外的属性数据</a></li>
<li><a href="#importing-extensionless-files">Importing Extensionless Files</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8configuration-trees">使用Configuration Trees</a></li>
<li><a href="#property-placeholders">Property Placeholders</a></li>
<li><a href="#working-with-multi-document-files">Working With Multi-Document Files</a></li>
<li><a href="#activation-properties">Activation Properties</a></li>
</ul>
</li>
<li><a href="#%E5%B1%9E%E6%80%A7%E5%8A%A0%E5%AF%86">属性加密</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8yaml">使用YAML</a></li>
</ul>
<p>Spring Boot可以让你把配置的一些东西放到外部，这样，同样的代码可以在不同的环境下运行，你可以使用非常多样的外部的配置源，包括java属性文件（properties）、YAML文件、环境变量、或者命令行参数。Property可以通过<code>@Value</code>被直接注入到你的bean中，底层是通过<code>Environment</code>抽象机制实现的，或者可以通过<code>@ConfigurationProperties</code>绑定到结构化的对象。Spring Boot使用了一个非常特殊的<code>PropertySource</code>覆盖顺序，该顺序以一种合理的方式覆盖值。后面出现的属性源的属性会覆盖前面出现的属性源的属性，属性源的加载顺序如下，类似于头插法，后面的排到前面。</p>
<ul>
<li>通过<code>SpringApplication.setDefaultProperties</code>指定的默认属性；</li>
<li><code>@Configuration</code>类上的<code>@PropertySource</code>注解指定的属性源，需要注意的是，这样的属性源直到<code>ApplicationContext</code>刷新后，才会被添加到<code>Environment</code>中，对于一些需要在bean refresh之前读取的属性来说，这太迟了，配置无法生效到Bean，比如logging.*与spring.main.*这些属性；</li>
<li>Config data属性源，比如<code>application.properties</code>文件等;</li>
<li>一个<code>RandomValuePropertySource</code>属性源，里面只有<code>random.*</code>开头的属性;</li>
<li>操作系统环境变量;</li>
<li>Java系统属性比如<code>System.getProperties()</code>;</li>
<li>来自于java:comp/env的JNDI属性；</li>
<li><code>ServletContext</code>初始化参数;</li>
<li><code>ServletConfig</code>初始化参数;</li>
<li>来自于<code>SPRING_APPLICATION_JSON</code>中的属性(环境变量或者Java系统属性中内嵌的json);</li>
<li>命令行参数;</li>
<li>test的属性，在<code>@SpringBootTest</code>上使用;</li>
<li><code>@TestPropertySource</code>注解指定的属性源;</li>
<li>Devtools全局设置的属性，在$HOME/.config/spring-boot目录中。</li>
</ul>
<p>Config data属性源文件以下面的顺序加载：</p>
<ul>
<li>jar包内的application.proeprties属性源，也包括yaml格式的;</li>
<li>jar包内的指定profile的application.properties，类似于application-{profile}.properties这样格式的文件;</li>
<li>jar包外的application.properties属性源，也包括yaml格式的;</li>
<li>jar包外的指定profile的application.properties，类似于application-{profile}.properties这样格式的文件。</li>
</ul>
<p>配置文件在整个应用中只建议使用一种格式，如果既有.properties与.yml格式的配置文件，并且在同样的位置，优先加载.properties文件。
为了提供一个具体的例子，假设你现在开发了一个使用属性name的<code>@Component</code>，如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean</span> {
    <span class="hljs-meta">@Value(&quot;${name}&quot;)</span>
    <span class="hljs-keyword">private</span> String name;
}
</code></pre>
<p>在你的应用的classpath下面比如：jar包里面，可以放一个application.properties文件，里面含有一个name属性，当放到一个新的环境中执行的时候，可以在jar包外提供一个含有name属性的application.properties，他会覆盖内部的name属性；如果要进行一次性的测试，你可以使用命令行参数。比如<code>java -jar app.jar —name=“spring”</code>。actuator的env与configprops端点可以查看属性的值有哪些，你可以使用这2个端点分析异常的属性值。</p>
<h1 id="访问命令行参数的属性源">访问命令行参数的属性源</h1>
<p>默认情况下，SpringApplication会把--开头的命令行选项参数转换成属性，并添加到<code>Environment</code>中，就像前面说的，命令行参数属性的优先级比文件的属性源的方式的优先级高。如果你不想要命令行参数的属性被添加到<code>Environment</code>中，你可以通过<code>SpringApplication.setAddCommandLineProperties(false)</code>禁用这个功能。</p>
<h1 id="json属性">JSON属性</h1>
<p>环境变量与JVM系统属性对于属性的名字或者值通常有一些限制，为了解决这个这个问题，你可以把一批属性序列化成json赋值为SPRING_APPLICATION_JSON或者spring.application.json属性值，这2个名字的value会被解析并被添加到Environment中。例如下面的命令行方式指定环境变量:</p>
<pre><code class="language-bash">SPRING_APPLICATION_JSON=<span class="hljs-string">&#x27;{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}&#x27;</span> java -jar myapp.jar
</code></pre>
<p>前面例子解析的属性是<code>my.name=test</code>。
也可以以系统属性的方式提供:</p>
<pre><code class="language-bash"> java -Dspring.application.json=<span class="hljs-string">&#x27;{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}&#x27;</span> -jar myapp.jar
</code></pre>
<p>或者使用命令行选项:</p>
<pre><code class="language-bash">$ java -jar myapp.jar --spring.application.json=<span class="hljs-string">&#x27;{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}&#x27;</span>
</code></pre>
<p>如果你正在部署一个以前的传统的Application Server应用，你可以使用JNDI变量的方式提供<code>java:comp/env/spring.application.json</code>。</p>
<h1 id="外部的应用属性">外部的应用属性</h1>
<p>当应用启动时，Spring Boot会自动发现并加载application.yml与application.properties从下面的位置</p>
<ul>
<li>从classpath
<ul>
<li>classpath root</li>
<li>classpath下的/config包</li>
</ul>
</li>
<li>从当前的目录下
<ul>
<li>当前的目录.</li>
<li>./config当前目录的config目录下</li>
<li>/config目录下的直接子目录下</li>
</ul>
</li>
</ul>
<p>下面的优先级比上面的高，会覆盖上面的值，文件中的属性会以<code>PropertySources</code>的方式添加到<code>Environment</code>中，如果你不想要配置文件的名字叫做application，你可以通过设置<code>spring.config.name</code>来设置配置文件的名字，比如下面的例子会寻找myproject.properties或者myproject.yaml文件</p>
<pre><code class="language-bash">$ java -jar myproject.jar --spring.config.name=myproject
</code></pre>
<p>你可以可以指定加载配置文件的位置，这是通过<code>spring.config.location</code>属性定义的，这个属性可以接受逗号分隔的目录来指定多个搜索位置，比如：</p>
<pre><code class="language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">java -jar myproject.jar --spring.config.location=\
    optional:classpath:/default.properties,\
    optional:classpath:/override.properties</span>
</code></pre>
<p>optional:前缀表示位置是可选的，不存在也没任何关系。
<code>spring.config.name</code>、<code>spring.config.location</code>,、<code>spring.config.additional-location</code>3个属性需要较早的生效以便决定加载的文件位置，它们必须定义成环境变量或者系统属性或者命令行参数的形式，其他形式的方式无法生效。如果<code>spring.config.location</code>里面有目录，它们应该以/结尾，在运行时，它们会被追加上<code>spring.config.name</code>配置的名字，如果是直接指定的文件会被直接加载。
所有的目录与文件位置都支持自动加载profile相关的配置文件，比如你定义了下面的属性
<code>spring.config.location=classpath:myconfig.properties</code>那么<code>classpath:myconfig-&lt;profile&gt;.properties</code>文件也会自动加载.
在大多数场景下，每个<code>spring.config.location</code>中的位置都指定了一个文件或者一个目录，这些位置的加载顺序就是定义的的顺序，但是如果出现了同名的属性，后面的会覆盖前面的属性。如果你有复杂的位置设置并且使用profile相关的配置文件，你需要提供hint以便Spring Boot知道如何对它们进行分组，一个位置组就是位置的集合，集合中的所有位置是同等优先级的，或者说是同级的，比如，你可能想把所有的classpath locations分为一组，所有的外部位置分为一组，在一个位置组中的所有位置以;也就是分号分隔。使用<code>spring.config.location</code>配置的位置会替换默认的位置，比如，如果设置<code>spring.config.location=optional:classpath:/custom-config/,optional:file:./custom-config/</code>，完整的位置集合如下:</p>
<ul>
<li>optional:classpath:custom-config/;</li>
<li>optional:file:./custom-config/</li>
</ul>
<p>如果你想要添加额外的位置而不是替换默认的位置，你可以使用<code>spring.config.additional-location</code>属性设置，从额外位置加载的属性会覆盖默认位置的属性，比如，如果你设置<code>spring.config.additional-location=optional:classpath:/custom-config/,optional:file:./custom-config/</code>完整的位置集合如下:</p>
<ul>
<li>optional:classpath:/;optional:classpath:/config/;</li>
<li>optional:file:./;optional:file:./config/;optional:file:./config/*/;</li>
<li>optional:classpath:custom-config/;</li>
<li>optional:file:./custom-config/</li>
</ul>
<p>搜索顺序可以让你提供默认值机制，通常在默认位置的application.properties文件中，这些默认值可以通过额外的自定义位置的文件中的属性覆盖。如果你使用系统环境变量而不是系统属性，大多数的系统不允许使用句号分隔的key，你可以使用下划线替代比如，使用SPRING_CONFIG_NAME替换spring.config.name。</p>
<h2 id="optional-locations">Optional Locations</h2>
<p>默认情况下，当一个指定的配置位置不存在时，Spring Boot会抛出一个<code>ConfigDataLocationNotFoundException</code>异常并且你的应用不会启动，为了避免位置不存在的问题，你可以使用<code>optional:</code>前缀，你可以在<code>spring.config.location</code>与<code>spring.config.additional-location</code>以及<code>spring.config.import</code>3个属性中指定前缀，比如当设置<code> spring.config.import=optional:file:./myconfig.properties</code>时，即使文件不存在，应用也能启动，如果你想要忽略所有的<code>ConfigDataLocationNotFoundException</code>异常，你可以设置<code>spring.config.on-not-found=ignore</code>属性，这个属性可以通过<code>SpringApplication.setDefaultProperties(…​)</code>的方式设置或者环境变量或者系统属性。</p>
<h2 id="wildcard-locations">Wildcard Locations</h2>
<p>如果一个配置文件位置最后一级路径包含*字符，它会被认为是一个通配符位置，当配置被加载时通配符会被展开这样就会检查位置的直接子目录，通配符位置在K8s环境下特别有用，因为可能存在多个配置文件属性源。比如，如果你有一些Redis配置与一些MySQL配置，你可能想要让这2个配置分开，但是还必须都在application.properties文件中，使用2个位置的application.properties文件就可以解决这个问题，比如<code>/config/redis/application.properties</code>与<code>/config/mysql/application.properties</code>文件，在这个案例中，通配符位置config/*/会使这2个位置都被处理。默认情况下，Spring Boot本身就在默认位置包含config/*/位置配置，也就是说，jar目录的config直接子目录都会被搜索。在你自己指定的位置，你可以使用多个通配符位置。通配符位置只能包含一个*号，对于目录搜索位置来说，要以*/结尾，对于文件搜索位置来时，必须以*/&lt;filename&gt;的形式结尾，通配符位置基于文件绝对路径上的字符排序顺序搜索或者加载。通配符位置只对外部目录生效，classpath:位置不能使用。</p>
<h2 id="profile-specific-files">Profile Specific Files</h2>
<p>除了application属性文件外，Spring Boot也会尝试加载profile属性文件，文件的名字约定是application-{profile}，比如，如果你设置应用的profile=prod，同时使用yaml属性格式文件，那么application.yml以及application-prod.yml都会被加载。profile属性源的加载位置与application.properties文件的位置一致，并且同名属性会覆盖application.properties中的属性，如果指定了多个profile，那么同名属性使用last-wins策略，比如设置<code>spring.profiles.active=prod,live</code>，则application-live.properties中的属性会覆盖application-prod.properties中的属性，last-wins策略作用于位置组级别，
<code>spring.config.location=classpath:/cfg/,classpath:/ext/</code>与<code>spring.config.location=classpath:/cfg/;classpath:/ext/</code>将会有不同的覆盖规则。比如，我们有如下的文件</p>
<pre><code>/cfg
  application-live.properties
/ext
  application-live.properties
  application-prod.properties
</code></pre>
<p>当设置<code>spring.config.location=classpath:/cfg/,classpath:/ext/</code>时，我们会先处理/cfg下的所有文件，然后处理/ext下的所有文件:</p>
<ul>
<li>/cfg/application-live.properties</li>
<li>/ext/application-prod.properties</li>
<li>/ext/application-live.properties
当设置<code>spring.config.location=classpath:/cfg/;classpath:/ext/</code>时，我们处理/cfg与/ext按相同的目录层次处理:</li>
<li>/ext/application-prod.properties</li>
<li>/cfg/application-live.properties</li>
<li>/ext/application-live.properties</li>
</ul>
<p>Envionment具有默认的profile，也就是[default]，如果没有profile指定则使用它，也就是，没有指定profile，可以加载application-default属性配置文件。属性文件只会加载一次。</p>
<h2 id="导入额外的属性数据">导入额外的属性数据</h2>
<p>使用<code>spring.config.import</code>属性可以从别的位置导入属性数据，只要在导入的位置发现了属性文件就会被处理，会当作一个额外的属性文档立即插入到<code>spring.config.import</code>属性声明的下方，比如，你在application.properties文件中声明下面的属性:</p>
<pre><code class="language-properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">myapp</span>
<span class="hljs-attr">spring.config.import</span>=<span class="hljs-string">optional:file:./dev.properties</span>
</code></pre>
<p>这会导入当前目录下的dev.properties文件，文件中的属性值会覆盖触发导入的属性源中的属性，这里是application.properties，导入只会导入一次，不论声明多少次，且导入顺序任意，比如下面的配置的结果相同:</p>
<pre><code class="language-properties"><span class="hljs-attr">spring.config.import</span>=<span class="hljs-string">my.properties</span>
<span class="hljs-attr">my.property</span>=<span class="hljs-string">value</span>
</code></pre>
<pre><code>my.property=value
spring.config.import=my.properties
</code></pre>
<p><code>spring.config.import</code>可以指定多个位置，按照写的顺序处理，后面的覆盖前面的。导入也会导入profile描述的属性文件，比如上面导入dev.proprtties的例子也会自动导入dev-<profile>.properties文件。Spring Boot包含可扩展的API，可以支持各种不同形式的位置地址。默认情况下，您可以导入Java properties、YAML和configuration trees。第三方jar可以提供对其他技术的支持（不要求文件是本地的）。例如，您可以想象配置数据来自Consul、Apache ZooKeeper或Netflix Archaius等外部存储。如果您想支持自己的位置，请参阅<code>org.springframework.boot.context.config</code>包中的<code>ConfigDataLocationResolver</code>和 <code>ConfigDataLoader</code>类。</p>
<h2 id="importing-extensionless-files">Importing Extensionless Files</h2>
<p>某些云平台无法为卷挂载文件添加文件扩展名。要导入这些没有扩展名的文件，你需要给Spring Boot一个提示，让它知道如何加载它们。您可以通过在方括号中放置一个扩展提示来做到这一点。例如，假设您有一个/etc/config/myconfig文件，您希望将其导入为yaml。您可以使用以下命令从application.properties导入它:</p>
<pre><code class="language-yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span> <span class="hljs-string">&quot;file:/etc/config/myconfig[.yaml]&quot;</span>
</code></pre>
<h2 id="使用configuration-trees">使用Configuration Trees</h2>
<p>当在云平台（比如k8s）上运行应用时，你通常需要读取平台提供的配置值，出于此类目的使用环境变量并不少见，但这可能有缺点，尤其是在值应该保密的情况下。环境变量存在一种替换方式，很多云平台允许你将配置数据映射为挂载的数据卷，比如，k8s可以挂载ConfigMaps/Secrets为数据卷。存在2种常用的卷挂载模式:</p>
<ul>
<li>一个文件包含了全部的属性;</li>
<li>多个文件在一个目录树中，文件名作为key，value是文件的内容
对于第一种场景，你可以使用<code>spring.config.import</code>直接导入属性文件，第二种场景，你需要使用configtree:前缀，这样，spring boot知道它需要曝露所有的文件为属性，比如，我们假设k8s挂载了下面的卷</li>
</ul>
<pre><code>etc/
  config/
    myapp/
      username
      password
</code></pre>
<p>username文件的内容是属性配置值，password文件的内容是secret。为了导入这些属性，你需要将下面的配置添加到你的application.properties或者application.yaml文件中:</p>
<pre><code class="language-yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span> <span class="hljs-string">&quot;optional:configtree:/etc/config/&quot;</span>
</code></pre>
<p>然后你可以在Environment中访问属性<code>myapp.usernmae</code>与<code>myapp.password</code>，配置树中的目录形成了属性名的一部分，在上面的例子中，如果你要访问username或者password属性，你需要设置<code>spring.config.import=optional:configtree:/etc/config/myapp</code>，带有点号的文件名也可以诶正确的映射，/etc/config下面的myapp.username属性会生成一个myapp.username属性。Config Tree的值只能是String 或者byte[]类型的。如果你有多个config tree，它们有相同的父目录，你可以使用通配符形式快捷指定，任何以/*/结尾的configtree:位置会导入所有的子目录作为config trees。
比如，下面的卷</p>
<pre><code>etc/
  config/
    dbconfig/
      db/
        username
        password
    mqconfig/
      mq/
        username
        password
</code></pre>
<p>你可以这么指定:</p>
<pre><code class="language-yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span> <span class="hljs-string">&quot;optional:configtree:/etc/config/*/&quot;</span>
</code></pre>
<p>那么<code>db.username</code>，<code>db,password</code>，<code>mq.username</code>，<code>mq.password</code>属性。使用通配符加载的目录按字母顺序排序。如果您需要不同的顺序，那么您应该将每个位置列为单独的导入。config tree也可用于Docker secret。当Docker swarm服务被授予访问secret的权限时，secret就会被装载到容器中。例如，如果名为db.password的secret安装在位置/run/secrets/，您可以使用以下命令使db.password可用于Spring环境:</p>
<pre><code class="language-yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span> <span class="hljs-string">&quot;optional:configtree:/run/secrets/&quot;</span>
</code></pre>
<h2 id="property-placeholders">Property Placeholders</h2>
<p>在application.properties与application.yml文件中的值在使用时会经过<code>Environment</code>处理，所以你可以在其中引用前面定义的值（比如来自系统属性或者环境变量），值可以使用标准的属性占位符语法<code>${name}</code>，可以通过:指定属性占位符的默认值，比如<code>${name:default}</code>，下面是一个例子:</p>
<pre><code class="language-yaml"><span class="hljs-attr">app:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;MyApp&quot;</span>
  <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;${app.name} is a Spring Boot application written by ${username:Unknown}&quot;</span>
</code></pre>
<p>占位符中的属性名应该始终使用他们的标准形式(只使用小写字母的kebab-case形式)，这会使Spring Boot的处理逻辑与<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding">relaxed binding</a>中的一致，比如<code>${demo.item-price}</code>将会使用<code>demo.item-price</code>与<code>demo.itemPrice</code>属性，也可以使用环境变量中的<code>DEMO_ITEMPRICE</code>属性，如果你使用<code>${demo.itemPrice}</code>，那么<code>demo.item-price</code>与<code>DEMO_ITEMPRICE</code>将不会被选择.</p>
<h2 id="working-with-multi-document-files">Working With Multi-Document Files</h2>
<p>你可以将单一的物理文件拆分为多个逻辑文档，每个逻辑文档都是独立的，文档按照从上到下的顺序依次处理，后面文档中的属性覆盖前面文档中出现的属性。对于application.yml文件来说，使用YAML标准的多文档语法，3个连续的-用来分隔逻辑文档。比如，下面的文件有2个逻辑文档:</p>
<pre><code class="language-yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;MyApp&quot;</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;MyCloudApp&quot;</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">activate:</span>
      <span class="hljs-attr">on-cloud-platform:</span> <span class="hljs-string">&quot;kubernetes&quot;</span>
</code></pre>
<p>对于application.properties文件来说，使用特殊的#---或者!---注释来分隔逻辑文档:</p>
<pre><code class="language-properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">MyApp</span>
<span class="hljs-comment">#---</span>
<span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">MyCloudApp</span>
<span class="hljs-attr">spring.config.activate.on-cloud-platform</span>=<span class="hljs-string">kubernetes</span>
</code></pre>
<p>多文档属性通常与activation一起使用，比如<code>spring.config.activate.on-profile</code>,多文档属性文件不能使用<code>@PropertySource</code>与<code>@TestPropertySource</code>注解加载。</p>
<h2 id="activation-properties">Activation Properties</h2>
<p>有时候想要只activate给定的一组属性，这时候就要用到profile的机制，你可以通过属性<code>spring.config.activate.*</code>来设定相关的profile，可以使用的具体属性如下表:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Property</th>
<th style="text-align:left">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">on-profile</td>
<td style="text-align:left">指定的profile表达式，表明要active的proifle</td>
</tr>
<tr>
<td style="text-align:left">on-cloud-platform</td>
<td style="text-align:left">表明要active的CloudPlatform</td>
</tr>
</tbody>
</table>
<p>下面的例子描述了，只有当运行在kubernetes平台上并且指定了prod或者staging的profile时，才会active第二个文档:</p>
<pre><code class="language-yaml"><span class="hljs-attr">myprop:</span>
  <span class="hljs-string">&quot;always-set&quot;</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">activate:</span>
      <span class="hljs-attr">on-cloud-platform:</span> <span class="hljs-string">&quot;kubernetes&quot;</span>
      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">&quot;prod | staging&quot;</span>
<span class="hljs-attr">myotherprop:</span> <span class="hljs-string">&quot;sometimes-set&quot;</span>
</code></pre>
<h1 id="属性加密">属性加密</h1>
<p>Spring Boot没有提供任何内置的属性值加密支持，但是提供了钩子来修改Environment中的值，<code>EnvironmentPostProcessor</code>接口允许你在应用启动前，操作<code>Environment</code>，如果你需要一种安全的方式存储credentials与密码，<code>Spring Cloud Vault</code>项目提供了将外化配置存储到HashiCorp Vault的支持。</p>
<h1 id="使用yaml">使用YAML</h1>
<p>YAML是JSON的超集，它是一种便捷的指定层次化配置数据的方式，spring boot支持YAML，只要classpath下面有SnakeYAML库。YAML文档需要转换成<code>Environment</code>使用的properties格式，比如下面的YAML文档</p>
<pre><code class="language-yaml"><span class="hljs-attr">environments:</span>
  <span class="hljs-attr">dev:</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;https://dev.example.com&quot;</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Developer Setup&quot;</span>
  <span class="hljs-attr">prod:</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;https://another.example.com&quot;</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;My Cool App&quot;</span>
</code></pre>
<p>访问<code>Environment</code>中的属性时，它们会被转换成下面的形式:</p>
<pre><code class="language-properties"><span class="hljs-attr">environments.dev.url</span>=<span class="hljs-string">https://dev.example.com</span>
<span class="hljs-attr">environments.dev.name</span>=<span class="hljs-string">Developer Setup</span>
<span class="hljs-attr">environments.prod.url</span>=<span class="hljs-string">https://another.example.com</span>
<span class="hljs-attr">environments.prod.name</span>=<span class="hljs-string">My Cool App</span>
</code></pre>
<p>同样的，YAML list也需要转换成properties，使用[index]这样的格式表示数组，比如，考虑下面的YAML:</p>
<pre><code class="language-yaml"><span class="hljs-attr">my:</span>
 <span class="hljs-attr">servers:</span>
 <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;dev.example.com&quot;</span>
 <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;another.example.com&quot;</span>
</code></pre>
<p>转换后的形式:</p>
<pre><code class="language-properties"><span class="hljs-attr">my.servers[0]</span>=<span class="hljs-string">dev.example.com</span>
<span class="hljs-attr">my.servers[1]</span>=<span class="hljs-string">another.example.com</span>
</code></pre>
<p>[index]的形式可以绑定到Java的Set/List对象，YAML文件不能通过<code>@PropertySource</code>注解加载，如果你需要，那么用properties文件的形式</p>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>
Spring Boot可以让你把配置的一些东西放到外部，这样，同样的代码可以在不同的环境下运行，你可以使用非常多样的外部的配置源，包括java属性文件（properties）、YAML文件、环境变量、或者命令行参数。Property可以通过`@Value`被直接注入到你的bean中，底层是通过`Environment`抽象机制实现的，或者可以通过`@ConfigurationProperties`绑定到结构化的对象。Spring Boot使用了一个非常特殊的`PropertySource`覆盖顺序，该顺序以一种合理的方式覆盖值。后面出现的属性源的属性会覆盖前面出现的属性源的属性，属性源的加载顺序如下，类似于头插法，后面的排到前面。
- 通过`SpringApplication.setDefaultProperties`指定的默认属性；
- `@Configuration`类上的`@PropertySource`注解指定的属性源，需要注意的是，这样的属性源直到`ApplicationContext`刷新后，才会被添加到`Environment`中，对于一些需要在bean refresh之前读取的属性来说，这太迟了，配置无法生效到Bean，比如logging.\*与spring.main.\*这些属性；
- Config data属性源，比如`application.properties`文件等;
- 一个`RandomValuePropertySource`属性源，里面只有`random.*`开头的属性;
- 操作系统环境变量;
- Java系统属性比如`System.getProperties()`;
- 来自于java:comp/env的JNDI属性；
- `ServletContext`初始化参数;
- `ServletConfig`初始化参数;
- 来自于`SPRING_APPLICATION_JSON`中的属性(环境变量或者Java系统属性中内嵌的json);
- 命令行参数;
- test的属性，在`@SpringBootTest`上使用;
- `@TestPropertySource`注解指定的属性源;
- Devtools全局设置的属性，在$HOME/.config/spring-boot目录中。

Config data属性源文件以下面的顺序加载：
- jar包内的application.proeprties属性源，也包括yaml格式的;
- jar包内的指定profile的application.properties，类似于application-{profile}.properties这样格式的文件;
- jar包外的application.properties属性源，也包括yaml格式的;
- jar包外的指定profile的application.properties，类似于application-{profile}.properties这样格式的文件。

配置文件在整个应用中只建议使用一种格式，如果既有.properties与.yml格式的配置文件，并且在同样的位置，优先加载.properties文件。
为了提供一个具体的例子，假设你现在开发了一个使用属性name的`@Component`，如下：
```java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
@Component
public class MyBean {
    @Value("${name}")
    private String name;
}
```
在你的应用的classpath下面比如：jar包里面，可以放一个application.properties文件，里面含有一个name属性，当放到一个新的环境中执行的时候，可以在jar包外提供一个含有name属性的application.properties，他会覆盖内部的name属性；如果要进行一次性的测试，你可以使用命令行参数。比如`java -jar app.jar —name=“spring”`。actuator的env与configprops端点可以查看属性的值有哪些，你可以使用这2个端点分析异常的属性值。
# 访问命令行参数的属性源
默认情况下，SpringApplication会把--开头的命令行选项参数转换成属性，并添加到`Environment`中，就像前面说的，命令行参数属性的优先级比文件的属性源的方式的优先级高。如果你不想要命令行参数的属性被添加到`Environment`中，你可以通过`SpringApplication.setAddCommandLineProperties(false)`禁用这个功能。
# JSON属性
环境变量与JVM系统属性对于属性的名字或者值通常有一些限制，为了解决这个这个问题，你可以把一批属性序列化成json赋值为SPRING_APPLICATION_JSON或者spring.application.json属性值，这2个名字的value会被解析并被添加到Environment中。例如下面的命令行方式指定环境变量:
```bash
SPRING_APPLICATION_JSON='{"my":{"name":"test"}}' java -jar myapp.jar
```
前面例子解析的属性是`my.name=test`。
也可以以系统属性的方式提供:
```bash
 java -Dspring.application.json='{"my":{"name":"test"}}' -jar myapp.jar
```
或者使用命令行选项:
```bash
$ java -jar myapp.jar --spring.application.json='{"my":{"name":"test"}}'
```
如果你正在部署一个以前的传统的Application Server应用，你可以使用JNDI变量的方式提供`java:comp/env/spring.application.json`。
# 外部的应用属性
当应用启动时，Spring Boot会自动发现并加载application.yml与application.properties从下面的位置
- 从classpath
    - classpath root
    - /config
- 从当前的目录下
    - 当前的目录.
    - ./config当前目录的config文件夹下
    - /config文件下的直接子目录下
下面的优先级比上面的高，会覆盖上面的值，文件中的属性会以`PropertySources`的方式添加到`Environment`中，如果你不想要配置文件的名字叫做application，你可以通过设置`spring.config.name`来设置配置文件的名字，比如下面的例子会寻找myproject.properties或者myproject.yaml文件
```bash
$ java -jar myproject.jar --spring.config.name=myproject
```
你可以可以指定加载配置文件的位置，这是通过`spring.config.location`属性定义的，这个属性可以接受逗号分隔的目录来指定多个搜索位置，比如：
```shell
$ java -jar myproject.jar --spring.config.location=\
    optional:classpath:/default.properties,\
    optional:classpath:/override.properties
```
optional:前缀表示位置是可选的，不存在也没任何关系。
`spring.config.name`、`spring.config.location`,、`spring.config.additional-location`3个属性需要较早的生效以便决定加载的文件位置，它们必须定义成环境变量或者系统属性或者命令行参数的形式，其他形式的方式无法生效。如果`spring.config.location`里面有目录，它们应该以/结尾，在运行时，它们会被追加上`spring.config.name`配置的名字，如果是直接指定的文件会被直接加载。
所有的目录与文件位置都支持自动加载profile相关的配置文件，比如你定义了下面的属性
`spring.config.location=classpath:myconfig.properties`那么`classpath:myconfig-<profile>.properties`文件也会自动加载.
在大多数场景下，每个`spring.config.location`中的位置都指定了一个文件或者一个目录，这些位置的加载顺序就是定义的的顺序，但是如果出现了同名的属性，后面的会覆盖前面的属性。如果你有复杂的位置设置并且使用profile相关的配置文件，你需要提供hint以便Spring Boot知道如何对它们进行分组，一个位置组就是位置的集合，集合中的所有位置是同等优先级的，或者说是同级的，比如，你可能想把所有的classpath locations分为一组，所有的外部位置分为一组，在一个位置组中的所有位置以;也就是分号分隔。使用`spring.config.location`配置的位置会替换默认的位置，比如，如果设置`spring.config.location=optional:classpath:/custom-config/,optional:file:./custom-config/`，完整的位置集合如下:
- optional:classpath:custom-config/;
- optional:file:./custom-config/
如果你想要添加额外的位置而不是替换默认的位置，你可以使用`spring.config.additional-location`属性设置，从额外位置加载的属性会覆盖默认位置的属性，比如，如果你设置`spring.config.additional-location=optional:classpath:/custom-config/,optional:file:./custom-config/`完整的位置集合如下:
- optional:classpath:/;optional:classpath:/config/;
- optional:file:./;optional:file:./config/;optional:file:./config/*/;
- optional:classpath:custom-config/;
- optional:file:./custom-config/
搜索顺序可以让你提供默认值机制，通常在默认位置的application.properties文件中，这些默认值可以通过额外的自定义位置的文件中的属性覆盖。如果你使用系统环境变量而不是系统属性，大多数的系统不允许使用句号分隔的key，你可以使用下划线替代比如，使用SPRING_CONFIG_NAME替换spring.config.name。
## Optional Locations
默认情况下，当一个指定的配置位置不存在时，Spring Boot会抛出一个`ConfigDataLocationNotFoundException`异常并且你的应用不会启动，为了避免位置不存在的问题，你可以使用`optional:`前缀，你可以在`spring.config.location`与`spring.config.additional-location`以及`spring.config.import`3个属性中指定前缀，比如当设置` spring.config.import=optional:file:./myconfig.properties`时，即使文件不存在，应用也能启动，如果你想要忽略所有的`ConfigDataLocationNotFoundException`异常，你可以设置`spring.config.on-not-found=ignore`属性，这个属性可以通过`SpringApplication.setDefaultProperties(…​)`的方式设置或者环境变量或者系统属性。
## Wildcard Locations
如果一个配置文件位置最后一级路径包含*字符，它会被认为是一个通配符位置，当配置被加载时通配符会被展开这样就会检查位置的直接子目录，通配符位置在K8s环境下特别有用，因为可能存在多个配置文件属性源。比如，如果你有一些Redis配置与一些MySQL配置，你可能想要让这2个配置分开，但是还必须都在application.properties文件中，使用2个位置的application.properties文件就可以解决这个问题，比如`/config/redis/application.properties`与`/config/mysql/application.properties`文件，在这个案例中，通配符位置config/*/会使这2个位置都被处理。默认情况下，Spring Boot本身就在默认位置包含config/*/位置配置，也就是说，jar目录的config直接子目录都会被搜索。在你自己指定的位置，你可以使用个通配符位置。通配符位置只能包含一个\*号，对于目录搜索位置来说，要以\*/结尾，对于文件搜索位置来时，必须以\*/<filename>的形式结尾，通配符位置基于文件绝对路径上的字符排序顺序搜索或者加载。通配符位置只对外部目录生效，classpath:位置不能使用。
## Profile Specific Files
除了application属性文件外，Spring Boot也会尝试加载profile属性文件，文件的名字约定是application-{profile}，比如，如果你设置应用的profile=prod，同时使用yaml属性格式文件，那么application.yml以及application-prod.yml都会被加载。profile属性源的加载位置与application.properties文件的位置一致，并且同名属性会覆盖application.properties中的属性，如果指定了多个profile，那么同名属性使用last-wins策略，比如设置`spring.profiles.active=prod,live`，则application-live.properties中的属性会覆盖application-prod.properties中的属性，last-wins策略工作位置组级别，
`spring.config.location=classpath:/cfg/,classpath:/ext/`与`spring.config.location=classpath:/cfg/;classpath:/ext/`将会有不同的覆盖规则。比如，我们有如下的文件
```
/cfg
  application-live.properties
/ext
  application-live.properties
  application-prod.properties
```
当设置`spring.config.location=classpath:/cfg/,classpath:/ext/`时，我们会先处理/cfg下的所有文件，然后处理/ext下的所有文件:
- /cfg/application-live.properties
- /ext/application-prod.properties
- /ext/application-live.properties
当设置`spring.config.location=classpath:/cfg/;classpath:/ext/`时，我们处理/cfg与/ext按相同的目录层次处理:
- /ext/application-prod.properties
- /cfg/application-live.properties
- /ext/application-live.properties
Envionment具有默认的profile，也就是[default]，如果没有profile指定则使用它，也就是，没有指定profile，可以加载application-default属性配置文件。属性文件只会加载一次。
## 导入额外的属性数据




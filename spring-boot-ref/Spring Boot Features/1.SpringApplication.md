## Application Events and Listener
除了标准的Spring Framework事件外，比如ContextRefreshEvent，SpringApplication也会发送额外的应用事件，一些事件是在ApplicationContext创建前发布的，所以这时候你不能注册事件的监听器为一个@Bean，你可以通过`SpringApplication.addListener(...)`方法或者`SpringApplicationBuilder.listeners(...)`方法的方式添加监听器。如果你想要自动注册这些监听器，不管应用创建的方式，你可以添加META-INF/spring.factories到你项目下，使用org.springframework.context.ApplicationListener引用你实现的监听器，如下面的例子所示:
```properties
org.springframework.context.ApplicationListener=com.example.project.MyListener
```
应用事件会以下面的顺序发送
- ApplicationStartingEvent，在程序的运行开始前发送，但是在监听器与初始化器注册后发送;
- `ApplicationEnvironmentPreparedEvent`，当上下文中的Environment可用时发送，但是在容器创建前;
- `ApplicationContextInitializedEvent`在ApplicationContext准备完全并且ApplicationContextInitializers被调用后发送，但是在加载任何的Bean定义前发送;
- `ApplicationPreparedEvent`加载完Bean定义后，refresh执行前发送;
- `ApplicationStartedEvent`context执行完refresh，但是在application runner与command-line runner被调用前发送;
- `AvailabilityChangeEvent`在`LivenessState.CORRECT`之后马上发送，表示应用是live状态;
- `ApplicationReadyEvent`在application runner与command-line runner被调用后发送;
- `AvailabilityChangeEvent`在`ReadinessState.ACCEPTING_TRAFFIC`后发送，表示应用准备服务请求;
- `ApplicationFailedEvent`如果在启动阶段发生异常，就会发送这个事件.
上面的列表只包含SpringApplication本身的事件，除了这些，在发送`ApplicationPreparedEvent`事件后`ApplicationStartedEvent`事件前，还会发布下面的事件:
- `WebServerInitializedEvent`在WebServer启动后发布，对应命令式与响应式的实现类是`ServletWebServerInitializedEvent`与`ReactiveWebServerInitializedEvent`;
- `ContextRefreshedEvent`事件在ApplicationContext刷新后发送
通常来说，你可能用不到应用事件，但是知道它们存在是非常有必要的，在spring内部，Spring Boot使用这些事件操作大量的任务；事件监听器不应该执行运行事件比较长的任务，因为它们缺省都是执行在一个线程中，可以考虑使用application and command-line runners。应用事件的发布也是使用的Spring框架的标准事件发布机制，这个机制可以保证事件发布可以被子context中的监听器监听，也可以被祖先context中的监听器监听，因此，如果你的应用存在context的层级关系，一个监听器就会监听到多个context的相同事件。为了让您的监听器区分自己的context的事件和后代context的事件，它注入其所在的Context，然后将注入的Context与事件的Context进行比较。可以通过实现`ApplicationContextAware`来注入Context，或者如果监听器是bean也可以使用`@Autowired`。

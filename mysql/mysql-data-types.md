[TOC]
# JSON数据类型
MySQL支持RFC7159定义的Json数据类型，相比于存储string类型，json类型的优势如下：
- json格式自动校验；
- 存储格式优化，json文档是按照一种内部格式存储的，这种内部格式支持快速的访问内部节点，当服务需要读取一个json文档时，json文档不需要从一个文本表示的字符串中反序列化，json文档的二进制格式就支持查询子对象或者内嵌的值。
MySQL8支持JSON Merge Patch格式（使用JSON_MERGE_PATCH()函数），可以详细查看这个函数的描述。
json类型的存储空间==LONGBLOB与LONGTEXT的大小，可以看11.7节 数据类型的空间需求；需要记住的一点是，json文档的大小不能超过max_allow_packet系统变量的设置的上限，你可以使用函数json_storage_size()来确定json文档的存储空间大小。
在8.0.13之前的版本json列不支持默认值设置。json数据类型有很多支持的函数，分为3类，创建、操作、搜索；想要查看更多的函数的细节，可以看12.18节的JSON函数部分。
json列，与其他的二进制数据类型一样，是不能被直接索引的，你可以从json中的某个值上单独生成一列，在这个列上创建索引，可以看[Indexing a Generated Column to Provide a JSON Column Index](https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html#json-column-indirect-index)获取更多的信息。
MySQL优化器也会在匹配JSON表达式的虚拟列上寻找兼容的索引。
MySQL 8.0.17之后的版本，InnoDB存储引擎支持在JSON数组上建立多值索引。
MySQL NDB集群支持JSON数据类型与相关的函数，包括在有JSON列生成的列上建立索引，一个NDB表最多支持3个JSON列。
## JSON局部更新
在MySQL8.0中，优化器会局部更新JSON值，而不是采用的移除旧值再完整写入新值的的方式，满足以下条件的更新会使用到这个优化
- 被更新的列的类型是JSON;
- UPDTAE语句使用3个函数中的JSON_SET()、JSON_REPLACE()或者JSON_REMOVE()任意一个来更新列，json列值的直接赋值的方式不会执行局部更新，比如如下的SQL语句
```sql
UPDATE mytable SET jcol = '{"a": 10, "b": 25}'
```
在一个UPDATE语句中更新多个JSON列可以使用这种方式优化，MySQL可以对这些列执行局部更新，但是这有更新使用的是上面3个函数的情况下才可以。
- 输入列与目标列必须是同一个列，一个这样的UPDATE语句不能使用局部更新
```sql
UPDATE mytable SET jcol1 = JSON_SET(jcol2, '$.a', 100)
```
上面的更新的函数可以内嵌调用，或者组合调用，只要输入列与输出列是一个就行.
- 所有替换值的操作，比如替换对象或者替换数组；
- 替换的新值不能比以前的值大;
区分存储在表中的 JSON 列值的部分更新与将行的部分更新写入二进制日志很重要。 JSON 列的完整更新可以作为部分更新记录在二进制日志中。 当上一个列表中的最后两个条件中的一个（或两个）不满足但其他条件得到满足时，就会发生这种情况。
## Creating JSON Values
一个JSON的数组包含一些逗号分隔的值，使用[]符号包裹;如下：
```json
["abc", 10, null, true, false]
```
JSON对象是逗号分隔的key-value集合，使用()包裹,如下:
```json
{"k1": "value", "k2": 10}
```
正如例子中说明的那样，JSON数组与对象可以包含标量值，json对象中的key必须是字符串，标量值也包含时间类型的值.
```json
["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
```
json对象与json数组可以互相嵌套
```json
[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
```
你可以通过MySQL的函数的到JSON值，或者通过CAST(value as JSON)函数把其他类型的值转换成JSON类型来获得json值，下面的几个例子将会讲述MySQL是如何操作输入的JSON值。
在MySQL中，JSON值是以字符串的方式存储的，在一个需要json的上下文中，MySQL会自动解析string成json值，如果string不是一个有效的json值，就会抛出异常；这些上下文宝库向一个json列写入值，向一个json函数传递参数等；正如下面的例子中所示：
- 向一个json类型的列写值
```sql
mysql> CREATE TABLE t1 (jdoc JSON);
Query OK, 0 rows affected (0.20 sec)

mysql> INSERT INTO t1 VALUES('{"key1": "value1", "key2": "value2"}');
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO t1 VALUES('[1, 2,');
ERROR 3140 (22032) at line 2: Invalid JSON text:
"Invalid value." at position 6 in value (or column) '[1, 2,'.
```
此类错误消息中“在位置 N”的位置是基于 0 的，但应被视为值中问题实际发生位置的粗略指示。 
json_type()函数期望一个json参数并把参数解析成jsonvalue，它返回json的类型，如果不是有效的json，会返回一个错误.
```sql
mysql> SELECT JSON_TYPE('["a", "b", 1]');
+----------------------------+
| JSON_TYPE('["a", "b", 1]') |
+----------------------------+
| ARRAY                      |
+----------------------------+

mysql> SELECT JSON_TYPE('"hello"');
+----------------------+
| JSON_TYPE('"hello"') |
+----------------------+
| STRING               |
+----------------------+

mysql> SELECT JSON_TYPE('hello');
ERROR 3146 (22032): Invalid data type for JSON data in argument 1
to function json_type; a JSON string or JSON type is required.
```
MySQL 使用 utf8mb4 字符集和 utf8mb4_bin 排序规则处理 JSON 上下文中使用的字符串。 其他字符集中的字符串根据需要转换为 utf8mb4。 （对于 ascii 或 utf8 字符集中的字符串，不需要转换，因为 ascii 和 utf8 是 utf8mb4 的子集。
作为使用文字字符串编写 JSON 值的替代方法，存在用于从组件元素组合 JSON 值的函数。 JSON_ARRAY() 接受一个（可能是空的）值列表并返回一个包含这些值的 JSON 数组.
```sql
mysql> SELECT JSON_ARRAY('a', 1, NOW());
+----------------------------------------+
| JSON_ARRAY('a', 1, NOW())              |
+----------------------------------------+
| ["a", 1, "2015-07-27 09:43:47.000000"] |
+----------------------------------------+
```
json_object()根据key-value对生成json对象，
```sql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}            |
+---------------------------------------+
```
json_merge_preserve()函数输入多个json，并组合到一起;
```sql
mysql> SELECT JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}');
+-----------------------------------------------------+
| JSON_MERGE_PRESERVE('["a", 1]', '{"key": "value"}') |
+-----------------------------------------------------+
| ["a", 1, {"key": "value"}]                          |
+-----------------------------------------------------+
1 row in set (0.00 sec)
```
关于merge的更多的规则，可以参阅[Normalization, Merging, and Autowrapping of JSON Values](https://dev.mysql.com/doc/refman/8.0/en/json.html#json-normalization)
MySQL 8.0.3之后的版本也支持json_merge_patch函数，有一些不同的行为，阅读[JSON_MERGE_PATCH() compared with JSON_MERGE_PRESERVE()](https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#json-merge-patch-json-merge-preserve-compared)获得2个函数区别的信息.
json可以被分配给用户定义的变量
```sql
mysql> SET @j = JSON_OBJECT('key', 'value');
mysql> SELECT @j;
+------------------+
| @j               |
+------------------+
| {"key": "value"} |
+------------------+
```
但是，用户定义的变量不能是 JSON 数据类型，因此虽然前面示例中的 @j 看起来像一个 JSON 值并且具有与 JSON 值相同的字符集和排序规则，但它不具有 JSON 数据类型。 相反，JSON_OBJECT() 的结果在分配给变量时会转换为字符串。

通过转换 JSON 值生成的字符串具有 utf8mb4 字符集和 utf8mb4_bin 排序规则.
```sql
mysql> SELECT CHARSET(@j), COLLATION(@j);
+-------------+---------------+
| CHARSET(@j) | COLLATION(@j) |
+-------------+---------------+
| utf8mb4     | utf8mb4_bin   |
+-------------+---------------+
```
因为utf8mb4_bin是二进制的排序规则，所以JSON的比较是大小写敏感的。
```sql
mysql> SELECT JSON_ARRAY('x') = JSON_ARRAY('X');
+-----------------------------------+
| JSON_ARRAY('x') = JSON_ARRAY('X') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
```
区分大小写也适用于 JSON null、true 和 false 文字，它们必须始终以小写形式编写：
```sql
mysql> SELECT JSON_VALID('null'), JSON_VALID('Null'), JSON_VALID('NULL');
+--------------------+--------------------+--------------------+
| JSON_VALID('null') | JSON_VALID('Null') | JSON_VALID('NULL') |
+--------------------+--------------------+--------------------+
|                  1 |                  0 |                  0 |
+--------------------+--------------------+--------------------+

mysql> SELECT CAST('null' AS JSON);
+----------------------+
| CAST('null' AS JSON) |
+----------------------+
| null                 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT CAST('NULL' AS JSON);
ERROR 3141 (22032): Invalid JSON text in argument 1 to function cast_as_json:
"Invalid value." at position 0 in 'NULL'.
```
JSON 文字的区分大小写与 SQL NULL、TRUE 和 FALSE 文字的区分大小写不同，后者可以写成任何字母。
```sql
mysql> SELECT ISNULL(null), ISNULL(Null), ISNULL(NULL);
+--------------+--------------+--------------+
| ISNULL(null) | ISNULL(Null) | ISNULL(NULL) |
+--------------+--------------+--------------+
|            1 |            1 |            1 |
+--------------+--------------+--------------+
```
有时可能需要或希望在 JSON 文档中插入引号字符（" 或 '）。假设在此示例中，您要插入一些包含字符串的 JSON 对象，这些字符串表示一些有关 MySQL 的一些事实的句子，每个对象与适当的关键字配对 , 到使用此处显示的 SQL 语句创建的表中：
```sql
mysql> CREATE TABLE facts (sentence JSON);
```
这些陈述的一个例子是:mascot: The MySQL mascot is a dolphin named "Sakila".
将其作为 JSON 对象插入到事实表中的一种方法是使用 MySQL JSON_OBJECT() 函数。 在这种情况下，您必须使用反斜杠对每个引号字符进行转义，如下所示：
如果您将值作为 JSON 对象文字插入，则这不会以相同的方式工作，在这种情况下，您必须使用双反斜杠转义序列，如下所示：
```sql
mysql> INSERT INTO facts VALUES
     >   ('{"mascot": "Our mascot is a dolphin named \\"Sakila\\"."}');
```
使用双反斜杠可以防止 MySQL 执行转义序列处理，而是使其将字符串文字传递给存储引擎进行处理。 以上述任一方式插入 JSON 对象后，您可以通过执行简单的 SELECT 看到反斜杠出现在 JSON 列值中，如下所示：
```sql
mysql> SELECT sentence FROM facts;
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
```
要使用mascot作为关键字查找这个特定的句子，您可以使用列路径运算符 ->，如下所示：
```sql
mysql> SELECT col->"$.mascot" FROM qtest;
+---------------------------------------------+
| col->"$.mascot"                             |
+---------------------------------------------+
| "Our mascot is a dolphin named \"Sakila\"." |
+---------------------------------------------+
1 row in set (0.00 sec)
```
这使反斜杠以及周围的引号保持完整。 要使用mascot作为键显示所需的值，但不包括周围的引号或任何转义符，请使用内联路径运算符 ->>，如下所示：
```sql
mysql> SELECT sentence->>"$.mascot" FROM facts;
+-----------------------------------------+
| sentence->>"$.mascot"                   |
+-----------------------------------------+
| Our mascot is a dolphin named "Sakila". |
+-----------------------------------------+
```
需要注意的地方:
如果启用了 NO_BACKSLASH_ESCAES 服务器 SQL 模式，则前面的示例将无法正常工作。 如果设置了此模式，则可以使用单个反斜杠而不是双反斜杠来插入 JSON 对象文字，并保留反斜杠。 如果在执行插入时使用 JSON_OBJECT() 函数并且设置了此模式，则必须交替使用单引号和双引号，如下所示：
```sql
mysql> INSERT INTO facts VALUES
     > (JSON_OBJECT('mascot', 'Our mascot is a dolphin named "Sakila".'));
```
## json值的Normalization、Merging、Autowrapping
当一个字符串被解析，并且是一个有效的JSON对象时，在这个过程中，它也被标注化处理了，这意味着重复的key的值会被覆盖，下面是一个例子
```sql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": "def", "key2": "abc"}                       |
+------------------------------------------------------+
```
当json被写入到列时，也会执行标准化
```sql
mysql> CREATE TABLE t1 (c1 JSON);

mysql> INSERT INTO t1 VALUES
     >     ('{"x": 17, "x": "red"}'),
     >     ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

mysql> SELECT c1 FROM t1;
+------------------+
| c1               |
+------------------+
| {"x": "red"}     |
| {"x": [3, 5, 7]} |
+------------------+
```
这种“最后一个重复键获胜”行为是由 RFC 7159 建议的，并且大多数 JavaScript 解析器都实现了。
在 MySQL 8.0.3 之前的版本中，具有与文档中较早找到的键重复的键的成员将被丢弃。 以下 JSON_OBJECT() 调用生成的对象值不包含第二个 key1 元素，因为该键名称出现在值的较早位置：
```sql
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": 1, "key2": "abc"}                           |
+------------------------------------------------------+
```
在 MySQL 8.0.3 之前，在将值插入 JSON 列时也会执行这种“第一个重复键获胜”规范化。
```sql
mysql> CREATE TABLE t1 (c1 JSON);

mysql> INSERT INTO t1 VALUES
     >     ('{"x": 17, "x": "red"}'),
     >     ('{"x": 17, "x": "red", "x": [3, 5, 7]}');

mysql> SELECT c1 FROM t1;
+-----------+
| c1        |
+-----------+
| {"x": 17} |
| {"x": 17} |
+-----------+
```
MySQL 还会丢弃原始 JSON 文档中的键、值或元素之间的额外空白，并在显示时在每个逗号 (,) 或冒号 (:) 后面留下（或在必要时插入）一个空格。 这样做是为了提高可读性。
生成 JSON 值的 MySQL 函数（请参阅第 12.18.2 节，“创建 JSON 值的函数”）始终返回规范化值。
为了提高查找效率，MySQL 还对 JSON 对象的键进行排序。 您应该知道，此排序的结果可能会发生变化，并且不能保证跨版本保持一致。
## Merging JSON Values
MySQL 8.0.3（及更高版本）支持两种合并算法，由函数 JSON_MERGE_PRESERVE() 和 JSON_MERGE_PATCH() 实现。 它们在处理重复键的方式上有所不同：JSON_MERGE_PRESERVE() 保留重复键的值，而 JSON_MERGE_PATCH() 丢弃除最后一个值之外的所有值。 接下来的几段将解释这两个函数中的每一个如何处理 JSON 文档（即对象和数组）的不同组合的合并。
JSON_MERGE_PRESERVE() 与 MySQL 以前版本中的 JSON_MERGE() 函数相同（在 MySQL 8.0.3 中重命名）。 JSON_MERGE() 在 MySQL 8.0 中仍受支持作为 JSON_MERGE_PRESERVE() 的别名，但已被弃用并在未来版本中被删除。
合并数组。 在组合多个数组的上下文中，数组合并为一个数组。 JSON_MERGE_PRESERVE() 通过将稍后命名的数组连接到第一个数组的末尾来做到这一点。 JSON_MERGE_PATCH() 将每个参数视为由单个元素组成的数组（因此将 0 作为其索引），然后应用“最后一个重复键获胜”逻辑以仅选择最后一个参数。 您可以比较此查询显示的结果：
```sql
mysql> SELECT
    ->   JSON_MERGE_PRESERVE('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Preserve,
    ->   JSON_MERGE_PATCH('[1, 2]', '["a", "b", "c"]', '[true, false]') AS Patch\G
*************************** 1. row ***************************
Preserve: [1, 2, "a", "b", "c", true, false]
   Patch: [true, false]
```
合并后的多个对象会生成一个对象。 JSON_MERGE_PRESERVE() 通过组合数组中该键的所有唯一值来处理具有相同键的多个对象； 然后将此数组用作结果中该键的值。 JSON_MERGE_PATCH() 丢弃找到重复键的值，从左到右工作，因此结果只包含该键的最后一个值。 以下查询说明了重复键 a 的结果差异：
```sql
mysql> SELECT
    ->   JSON_MERGE_PRESERVE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Preserve,
    ->   JSON_MERGE_PATCH('{"a": 3, "b": 2}', '{"c": 3, "a": 4}', '{"c": 5, "d": 3}') AS Patch\G
*************************** 1. row ***************************
Preserve: {"a": [1, 4], "b": 2, "c": [3, 5], "d": 3}
   Patch: {"a": 4, "b": 2, "c": 5, "d": 3}
```
在需要数组值的上下文中使用的非数组值是自动包装的：该值由 [ 和 ] 字符包围以将其转换为数组。 在以下语句中，每个参数都自动包装为一个数组 ([1], [2])。 然后将它们合并以生成单个结果数组； 与前两种情况一样，JSON_MERGE_PRESERVE() 组合具有相同键的值，而 JSON_MERGE_PATCH() 丢弃除最后一个之外的所有重复键的值，如下所示：
```sql
mysql> SELECT
	  ->   JSON_MERGE_PRESERVE('1', '2') AS Preserve,
	  ->   JSON_MERGE_PATCH('1', '2') AS Patch\G
*************************** 1. row ***************************
Preserve: [1, 2]
   Patch: 2
```
数组和对象值通过将对象自动包装为数组并根据合并函数的选择（分别为 JSON_MERGE_PRESERVE() 或 JSON_MERGE_PATCH()）组合值或通过“最后一个重复键获胜”来合并数组，如可以 在这个例子中看到：
```sql
mysql> SELECT
	  ->   JSON_MERGE_PRESERVE('[10, 20]', '{"a": "x", "b": "y"}') AS Preserve,
	  ->   JSON_MERGE_PATCH('[10, 20]', '{"a": "x", "b": "y"}') AS Patch\G
*************************** 1. row ***************************
Preserve: [10, 20, {"a": "x", "b": "y"}]
   Patch: {"a": "x", "b": "y"}
```
## 搜索与更改JSON值
JSON路径表达式就是从JSON中选择一个值。
路径表达式常常用在需要解析json部分值或者修改部分值的函数中，路径表达式是为了描述需要操作文档的哪个部分。比如，下面的查询从一个json中解析出key=name的值:
```sql
mysql> SELECT JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name');
+---------------------------------------------------------+
| JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name') |
+---------------------------------------------------------+
| "Aztalan"                                               |
+---------------------------------------------------------+
```
路径表达式的语法以一个\$开始，表示正在使用的JSON文档，后面可选的跟一些连续的选择符，用来具体的指定json文档的具体部分。
- 后面跟对象中key的名字，如果名字中存在特殊的字符，名字必须使用双引号括起来;
- [N] 附加到选择数组的路径后，命名数组中位置 N 处的值。 数组位置是从零开始的整数。 如果 path 未选择数组值，则 path[0] 计算为与 path 相同的值;
```sql
mysql> SELECT JSON_SET('"x"', '$[0]', 'a');
+------------------------------+
| JSON_SET('"x"', '$[0]', 'a') |
+------------------------------+
| "a"                          |
+------------------------------+
1 row in set (0.00 sec)
```
- [***M*** to ***N***] 指定需要提取数组中数据的范围或者子集，其中last是一个关键词，等价于数组元素最右面值的编号，还支持数组元素的相对寻址，如果 ***path*** 选择的值不是一个数组，那么path[last]等价于 ***path***，后面的章节会讲。
- 路径可以包含*与**通配符:
      - .[*]匹配json对象中的所有成员的值，输出一个值的数组;
      - [*]表示json数组的所有的元素;
      - ***prefix***\*\****suffix*** 匹配所有的路径，这些路径的名字以  ***prefix*** 开始，以 ***suffix*** 字符结束;
- json文档中不存在的路径等价于NULL

让\$引用下面3个元素的json数组
```json
[3, {"a": [5, 6], "b": 10}, [99, 100]]
```
然后
- $[0]=3;
- $[1]={"a": [5, 6], "b": 10};
- $[2]=[99,100];
- $[3] = NULL,因为$[1]与$[2]指向的是非标量值，他们可以作为路径表达式的基础来选择内嵌的值，比如:
- $[1].a=[5,6];
- $[1].a[1]=6;
- $[1].b=10;
- $[2][0]=99;
正如前面提到的，如果key的名字包含特殊的字符，需要使用双引号包起来，让我们看看这种用法;
```json
{"a fish": "shark", "a bird": "sparrow"}
```
可以看到对象中的keys都包含1个空格，所以必须被引起来。
- $."a fish"=shark;
- $."a bird"=sparrow。
使用通配符的路径表达式会产生包含多个值的数组
```sql
mysql> SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*') |
+---------------------------------------------------------+
| [1, 2, [3, 4, 5]]                                       |
+---------------------------------------------------------+
mysql> SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]');
+------------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]') |
+------------------------------------------------------------+
| [3, 4, 5]                                                  |
+------------------------------------------------------------+
```
在下面的例子中，路径\$**.b等价于以b结尾的路径（\$.a.b与\$.c.b）并产生匹配多个路径值的数组
```sql
mysql> SELECT JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b') |
+---------------------------------------------------------+
| [1, 2]                                                  |
+---------------------------------------------------------+
```
### json数组的范围
你可以使用 ***to*** 这个关键字描述json数组的子集，比如`$[1 to 3]`,下面的例子
```sql
mysql> SELECT JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[1 to 3]');
+----------------------------------------------+
| JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[1 to 3]') |
+----------------------------------------------+
| [2, 3, 4]                                    |
+----------------------------------------------+
1 row in set (0.00 sec)
```
语法是 ***M*** to ***N***，语法为 M 到 N，其中 M 和 N 分别是 JSON 数组中一系列元素的第一个和最后一个索引。 N 必须大于 M； M 必须大于或等于 0。数组元素从 0 开始索引。
### 最右边的数组元素
支持 last 关键字作为数组中最后一个元素的索引的同义词。 last - N 形式的表达式可用于相对寻址和范围内定义，如下所示：
```sql
mysql> SELECT JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[last-3 to last-1]');
+--------------------------------------------------------+
| JSON_EXTRACT('[1, 2, 3, 4, 5]', '$[last-3 to last-1]') |
+--------------------------------------------------------+
| [2, 3, 4]                                              |
+--------------------------------------------------------+
1 row in set (0.01 sec)
```
如果针对不是数组的值评估路径，则评估结果与将该值包装在单元素数组中的结果相同：
```sql
mysql> SELECT JSON_REPLACE('"Sakila"', '$[last]', 10);
+-----------------------------------------+
| JSON_REPLACE('"Sakila"', '$[last]', 10) |
+-----------------------------------------+
| 10                                      |
+-----------------------------------------+
1 row in set (0.00 sec)
```
您可以使用column->path 的语法将JSON 列标识符和 JSON 路径表达式用作 JSON_EXTRACT(column, path) 的同义词。 有关更多信息，请参阅第 12.18.3 节，“搜索 JSON 值的函数”。 另请参阅索引生成的列以提供 JSON 列索引。
一些函数采用现有的 JSON 文档，以某种方式对其进行修改，然后返回生成的修改后的文档。 路径表达式指示在文档中进行更改的位置。 例如，JSON_SET()、JSON_INSERT() 和 JSON_REPLACE() 函数都接受一个 JSON 文档，加上一个或多个路径-值对，这些对描述在哪里修改文档和要使用的值。 这些函数在处理文档中现有值和不存在值的方式上有所不同。
考虑下面的json文档
JSON_SET() 替换存在路径的值，并为不存在的路径添加值
```sql
mysql> SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+--------------------------------------------+
| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+--------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20, 2]]      |
+--------------------------------------------+
```
在这种情况下，路径 \$[1].b[0] 选择一个现有值 (true)，该值被路径参数 (1) 后面的值替换。 路径\$[2][2]不存在，所以对应的值(2)加到\$[2]选择的值上。
JSON_INSERT() 添加新值但不替换现有值：
```sql
mysql> SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+-----------------------------------------------+
| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+-----------------------------------------------+
| ["a", {"b": [true, false]}, [10, 20, 2]]      |
+-----------------------------------------------+
```
JSON_REPLACE() 替换现有值并忽略新值：
```sql
mysql> SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+------------------------------------------------+
| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+------------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20]]             |
+------------------------------------------------+
```
路径值对从左到右进行评估。 通过评估一对产生的文档成为评估下一对的新值。 
JSON_REMOVE() 接受一个 JSON 文档和一个或多个指定要从文档中删除的值的路径。 返回值是原始文档减去文档中存在的路径选择的值：
```sql
mysql> SELECT JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');
+---------------------------------------------------+
| JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |
+---------------------------------------------------+
| ["a", {"b": [true]}]                              |
+---------------------------------------------------+
```
## JSON路径语法
MySQL 支持许多 JSON 函数，这些函数在本手册的其他地方有详细的描述（请参阅第 12.18 节，“JSON 函数”）这些json函数大多数都需要路径表达式以标识 JSON 文档中的特定元素。 路径由路径的范围和一个或多个路径支路组成。 对于 MySQL JSON 函数中使用的路径，范围始终是正在搜索或以其他方式操作的文档，由前导 $ 字符表示。 路径段由句点字符 (.) 分隔。 数组中的单元格由 [N] 表示，其中 N 是非负整数。 键的名称必须是双引号字符串或有效的 ECMAScript 标识符（请参阅 ECMAScript 语言规范中的标识符名称和标识符）。 路径表达式（如 JSON 文本）应使用 ascii、utf8 或 utf8mb4 字符集进行编码。 其他字符编码被隐式强制为 utf8mb4。 完整的语法显示在这里
```sql
pathExpression:
    scope[(pathLeg)*]

pathLeg:
    member | arrayLocation | doubleAsterisk

member:
    period ( keyName | asterisk )

arrayLocation:
    leftBracket ( nonNegativeInteger | asterisk ) rightBracket

keyName:
    ESIdentifier | doubleQuotedString

doubleAsterisk:
    '**'

period:
    '.'

asterisk:
    '*'

leftBracket:
    '['

rightBracket:
    ']'
```
如前所述，在 MySQL 中，路径的作用域始终是被操作的文档，用\$表示。 您可以在 JSON 路径表达式中使用"$"作为文档的同义词。
通配符标记*与**是如下的用途
- *表示对象中的所有成员的值;
- [*]表示数组中的所有的元素;
- [prefix]\*\*suffix表示所有的以prefix开头，以suffix结尾的路径，prefix是可选的，但是suffix是必须的，换句话说，一个路径不能以\*\*结尾;
另外，一个路径不能包含***.
有关路径语法示例，请参阅将路径作为参数的各种 JSON 函数的说明，例如 JSON_CONTAINS_PATH()、JSON_SET() 和 JSON_REPLACE()。 有关包括使用 * 和 ** 通配符的示例，请参阅 JSON_SEARCH() 函数的说明。
MySQL 8.0 还支持使用 to 关键字（例如 $[2 to 10]）以及作为数组最右边元素的同义词的最后一个关键字的 JSON 数组子集的范围表示法。 有关更多信息和示例，请参阅搜索和修改 JSON 值。
## JSON值的比较与排序
JSON 值可以使用 =、<、<=、>、>=、<>、!= 和 <=> 运算符进行比较。
JSON 值尚不支持以下比较运算符和函数：
- BETWEEN
- IN()
- GREATEST()
- LEAST()
刚刚列出的比较运算符和函数的一种临时解决方法是将 JSON 值转换为原生 MySQL 数字或字符串数据类型，以便它们具有一致的非 JSON 标量类型.
JSON 值的比较发生在两个级别。 第一级比较基于比较值的 JSON 类型。 如果类型不同，则比较结果仅由具有更高优先级的类型决定。 如果两个值具有相同的 JSON 类型，则使用特定于类型的规则进行第二级比较。
以下列表显示了 JSON 类型的优先级，从最高优先级到最低优先级。 （类型名称是由 JSON_TYPE() 函数返回的名称。）一起显示在一行中的类型具有相同的优先级。 列表中前面列出的任何具有 JSON 类型的值都比列表中后面列出的任何具有 JSON 类型的值都大。
- BLOB
- BIT
- OPAQUE
- DATETIME
- TIME
- DATE
- BOOLEAN
- ARRAY
- OBJECT
- STRING
- INTEGER, DOUBLE
- NULL
对于相同优先级的 JSON 值，每种类型的比较规则都是不同的
- BLOB: 比较两个值的前 N 个字节，其中 N 是较短值中的字节数。 如果两个值的前 N 个字节相同，则较短的值排在较长的值之前;
- BIT: 与BLOB类型的规则一样;
- OPAQUE: 与 BLOB 的规则相同。 OPAQUE 值是未被归类为其他类型之一的值;
- DATETIME: 表示较早时间点的值排在表示较晚时间点的值之前。 如果两个值最初分别来自 MySQL DATETIME 和 TIMESTAMP 类型，则如果它们代表相同的时间点，则它们相等;
- TIME: 两个时间值中较小的在较大的之前排序;
- DATE:
- ARRAY: 如果两个 JSON 数组具有相同的长度并且数组中相应位置的值相等，则它们相等。如果数组不相等，则它们的顺序由存在差异的第一个位置的元素决定。 在该位置具有较小值的数组首先排序。 如果较短数组的所有值都等于较长数组中的对应值，则较短数组先排序;
- BOOLEAN: false<true
- OBJECT: 如果两个 JSON 对象具有相同的键集，并且每个键在两个对象中具有相同的值，则它们是相等的，两个不相等的对象的顺序是未指定的，但具有确定性;
- STRING: 字符串在被比较的两个字符串的 utf8mb4 表示的前 N 个字节上按词法排序，其中 N 是较短字符串的长度。 如果两个字符串的前 N 个字节相同，则较短的字符串被认为小于较长的字符串；此排序等效于使用排序规则 utf8mb4_bin 对 SQL 字符串进行排序。 由于 utf8mb4_bin 是二进制排序规则，因此 JSON 值的比较区分大小写;
- INTEGER,DOUBLE: JSON 值可以包含精确值数字和近似值数字。 有关这些类型数字的一般讨论，请参阅第 9.1.2 节“数字文字”。

比较本机 MySQL 数字类型的规则在第 12.3 节，“表达式评估中的类型转换”中讨论，但比较 JSON 值中的数字的规则有些不同：
   - 在分别使用原生 MySQL INT 和 DOUBLE 数字类型的两列之间的比较中，已知所有比较都涉及一个整数和一个双精度数，因此所有行的整数都转换为双精度数。 即，精确值数字被转换为近似值数字;
     - 另一方面，如果查询比较两个包含数字的 JSON 列，则无法提前知道数字是整数还是双精度数。 为了在所有行中提供最一致的行为，MySQL 将近似值数字转换为精确值数字。 结果排序是一致的，并且不会丢失精确值数字的精度;
 - 任何的json值与NULL值的比较，结果都是UNKNOWN。
JSON 和非 JSON 值的比较，根据下表中的规则将非 JSON 值转换为 JSON，然后按照前面描述的方法比较值。
## JSON与非JSON值的转换
下表总结了 MySQL 在 JSON 值和其他类型的值之间进行转换时遵循的规则：
|other type|other type as json|json as other type|
|:---|:---|:---|
|JSON|No change|No change|
|utf8 字符串类型(utf8mb4,utf8,ascii)|被解析为json|json被序列化为一个utf8mb4的字符串|
|其他字符串类型|其他字符串编码被隐式的转换为utf8mb4字符串，然后以utf8字符串的方式处理|json被序列化为一个utf8mb4的字符串，然后转换为其他的编码格式，结果可能是一个乱码|
|NULL|json类型的NULL|NULL|
|几何类型|||
|其他类型|一个包含单个标量值的json文档|如果json文档包含一个单个的变量值，并且这个标量值可以转换为目标类型，否则返回null|
JSON 值的 ORDER BY 和 GROUP BY 根据以下原则工作:
- 标量 JSON 值的排序使用与前面讨论相同的规则;
- 对于升序，SQL本身的NULL值在所有JSON值之前排序，包括JSON null类型的值；对于降序排序，SQL本身的NULL在所有JSON值之后排序，包括 JSON null JSON本身的null类型的值;
- JSON 值的排序键受 max_sort_length 系统变量的值约束，因此仅在第一个 max_sort_length 字节之后不同的键比较相等;
- 当前不支持对非标量值进行排序，并且会出现警告;
对于排序，将 JSON 标量转换为其他一些本机 MySQL 类型可能是有益的。 例如，如果名为 jdoc 的列包含具有由 id 键和非负值组成的成员的 JSON 对象，则使用此表达式按 id 值排序 `ORDER BY CAST(JSON_EXTRACT(jdoc, '$.id') AS UNSIGNED)`
如果恰好有一个生成的列被定义为使用与 ORDER BY 中相同的表达式，则 MySQL 优化器会识别出这一点并考虑将索引用于查询执行计划。 请参阅第 8.3.11 节，“生成的列索引的优化器使用”。
## JSON值的聚合操作
对于 JSON 值的聚合，SQL NULL 值与其他数据类型一样被忽略。 非 NULL 值转换为数字类型并聚合，MIN()、MAX() 和 GROUP_CONCAT() 除外。 对于数字标量的 JSON 值，转换为数字应该会产生有意义的结果，尽管（取决于值）可能会发生截断和精度损失。 转换为许多其他 JSON 值可能不会产生有意义的结果。


Apache Flink有2种关系型API来做流批统一处理: Table API与SQL，Table API是用于Scala和Java语言的查询API，它可以用一种非常直观的方式来组合使用选取、过滤、join等关系算子。Flink SQL是基于Apache Calcite来实现的标准SQL。无论输入是连续的还是有界的，在2个接口中指定的查询都具有相同的语义并指定相同的结果。Table API和SQL2种API是紧密集成的以及DataStream API。你可以在这些API之间以及一些基于这些API的库之间轻松的切换。比如，你可以先用CEP从DataStream中做模式匹配，然后用Table API来分析匹配的结果，或者你可以用SQL来扫描、过滤、聚合一个批式的表，然后再跑一个Gelly图算法来处理已经预处理好的数据。
你需要将Table API作为依赖项添加到项目中，以便Table API和SQL定义数据管道。
# 概念与通用API
Table API和SQL集成在同一套API中。这套API的核心概念是Table，用作查询的输入与输出。本文介绍Table API和SQL查询程序的通用结构、如何注册Table、如何查询Table以及如何输出Table。
## Table API和SQL程序的结构
所有用于批处理和流处理的Table API和SQL程序都遵循相同的模式。下面的代码示例展示了Table API和SQL程序的通用结构:
```java
import org.apache.flink.table.api.*;
import org.apache.flink.connector.datagen.table.DataGenConnectorOptions;

// Create a TableEnvironment for batch or streaming execution.
// See the "Create a TableEnvironment" section for details.
TableEnvironment tableEnv = TableEnvironment.create(/*…*/);

// Create a source table
tableEnv.createTemporaryTable("SourceTable", TableDescriptor.forConnector("datagen")
    .schema(Schema.newBuilder()
      .column("f0", DataTypes.STRING())
      .build())
    .option(DataGenConnectorOptions.ROWS_PER_SECOND, 100L)
    .build());

// Create a sink table (using SQL DDL)
tableEnv.executeSql("CREATE TEMPORARY TABLE SinkTable WITH ('connector' = 'blackhole') LIKE SourceTable (EXCLUDING OPTIONS) ");

// Create a Table object from a Table API query
Table table1 = tableEnv.from("SourceTable");

// Create a Table object from a SQL query
Table table2 = tableEnv.sqlQuery("SELECT * FROM SourceTable");

// Emit a Table API result Table to a TableSink, same for SQL result
TableResult tableResult = table1.insertInto("SinkTable").execute();
```
**注意**: Table API和SQL查询可以很容易地集成并嵌入到DataStream程序中。请参阅与[DataStream API集成](https://nightlies.apache.org/flink/flink-docs-release-1.16/zh/docs/dev/table/data_stream_api/)章节了解如何将DataStream与表之间相互转化。
## 创建TableEnvironment
TableEnvironment是Table API和SQL的核心概念。它负责:
- 在内部的catalog中注册Table;
- 注册外部的catalog;
- 加载可插拔模块;
- 执行SQL查询;
- 注册自定义函数(scalar、table或aggregation);
- DataStream和Table之间的转换(面向StreamTableEnvironment).

Table总是与特定的TableEnvironment绑定，不能在同一条查询中使用不同的TableEnvironment中的表，例如，对它们进行join或union操作。TableEnvironment可以通过静态方法`TableEnvironment.create()`创建。
```java
import org.apache.flink.table.api.EnvironmentSettings;
import org.apache.flink.table.api.TableEnvironment;
EnvironmentSettings settings = EnvironmentSettings
    .newInstance()
    .inStreamingMode()
    //.inBatchMode()
    .build();
TableEnvironment tEnv = TableEnvironment.create(settings);
```
或者用户可以从现有的StreamExecutionEnvironment创建一个StreamTableEnvironment与DataStream API互操作。
```java
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.table.api.EnvironmentSettings;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
StreamTableEnvironment tEnv = StreamTableEnvironment.create(env);
```
## 在Catalog中创建表
TableEnvironment维护着一个由标识符(identifier)创建的表catalog的映射。标识符由3个部分组成: catalog名称、数据库名称以及对象名称，如果catalog或者数据库没有指明，就会使用当前默认值(参见[表标识符扩展](https://nightlies.apache.org/flink/flink-docs-release-1.16/zh/docs/dev/table/common/#expanding-table-identifiers)章节中的例子)。Table可以是虚拟的(视图VIEWS)也可以是常规的(表TABLES)，视图VIEWS也可以从已经存在的Table中创建，一般是Table API或者SQL的查询结果。表TABLES描述的是外部数据，例如文件、数据库表或者消息队列。
### 临时表(Temporary Table)和永久表(Permanent Table)
表可以是临时的，并与单个Flink会话(session)的生命周期相关，也可以是永久的，并且在多个Flink会话和集群中可见。永久表需要catalog以维护表的元数据。一旦永久表被创建，它将对任何连接到catalog的Flink会话可见且持续存在，直至被明确删除。临时表通常保存于内存中并且仅在创建它们的flink会话持续期间存在。这些表对于其他会话是不可见的。它们不与任何catalog或者数据库绑定但可以在一个命名空间(namespace)中创建，即使它们对应的数据库被删除，临时表也不会被删除。
### 屏蔽(Shadowing)
可以使用与已存在的永久表相同的标识符去注册临时表，临时表会屏蔽永久表，并且只要临时表存在，永久表就无法访问。所有使用该标识符的查询都将作用于临时表。这可能对实验(experimentation)有用，它允许先对一个临时表进行完全相同的查询，例如只有一个子集的数据，或者数据是不确定的。一旦验证了查询的正确性，就可以对实际的生产表进行查询。
## 创建表
### 虚拟表
在SQL的术语中，Table API的对象对应于视图(虚拟表)。它封装了一个逻辑查询计划。可以通过一下方法在catalog中创建:
```java
// get a TableEnvironment
TableEnvironment tableEnv = ...; // see "Create a TableEnvironment" section
// table is the result of a simple projection query 
Table projTable = tableEnv.from("X").select(...);
// register the Table projTable as table "projectedTable"
tableEnv.createTemporaryView("projectedTable", projTable);
```
**注意**: 从传统数据库系统的角度来看，Table对象与VIEW视图非常像。也就是，定义了Table的查询是没有被优化的，而且会被嵌入到另一个引用了这个注册了的Table的查询中。如果多个查询都引用了同一个注册了的Table，那么它会被内嵌到每个查询中并被执行多次，也就是说注册了的Table的结果不会被共享。
#### Connector Tables
另外一个方式去创建TABLE是通过connector声明，Connector描述了存储表数据的外部系统。存储系统例如Apache Kafka或者常规的文件系统都可以通过这种方式来声明。这样的表可以直接通过Table API直接创建也可以直接通过SQL DDL创建。
```sql
// Using table descriptors
final TableDescriptor sourceDescriptor = TableDescriptor.forConnector("datagen")
    .schema(Schema.newBuilder()
    .column("f0", DataTypes.STRING())
    .build())
    .option(DataGenConnectorOptions.ROWS_PER_SECOND, 100L)
    .build();
tableEnv.createTable("SourceTableA", sourceDescriptor);
tableEnv.createTemporaryTable("SourceTableB", sourceDescriptor);
// Using SQL DDL
tableEnv.executeSql("CREATE [TEMPORARY] TABLE MyTable (...) WITH (...)");
```
## 扩展表标识符
表总是通过三元标识符注册，包括catalog名、数据库名和表名。用户可以指定一个catalog和数据库作为当前catalog和当前数据库。有了这些，那么刚刚提到的三元标识符的前两个部分就可以被省略了。如果前两部分的标识符没有指定， 那么会使用当前的catalog和当前数据库。用户也可以通过 Table API或SQL切换当前的catalog和当前的数据库。标识符遵循SQL标准，因此使用时需要用反引号`进行转义。
```java
TableEnvironment tEnv = ...;
tEnv.useCatalog("custom_catalog");
tEnv.useDatabase("custom_database");

Table table = ...;

// register the view named 'exampleView' in the catalog named 'custom_catalog'
// in the database named 'custom_database' 
tableEnv.createTemporaryView("exampleView", table);

// register the view named 'exampleView' in the catalog named 'custom_catalog'
// in the database named 'other_database' 
tableEnv.createTemporaryView("other_database.exampleView", table);

// register the view named 'example.View' in the catalog named 'custom_catalog'
// in the database named 'custom_database' 
tableEnv.createTemporaryView("`example.View`", table);

// register the view named 'exampleView' in the catalog named 'other_catalog'
// in the database named 'other_database' 
tableEnv.createTemporaryView("other_catalog.other_database.exampleView", table);
```
## 查询表
### Table API
Table API是关于Scala/Java的集成语言式查询API。与SQL相反，Table API的查询不是由字符串指定，而是在宿主语言中逐步构建。Table API是基于Table类的，该类表示一个表(流或者批处理)，并提供使用关系操作的方法。这些方法返回一个新的Table对象，该对象表示对输入Table进行关系操作的结果。一些关系操作由多个方法调用组成，例如`table.groupBy(...).select()`，其中`groupBy(...)`指定table的分组，而select(...)在table分组上的投影。文档[Table API](https://nightlies.apache.org/flink/flink-docs-release-1.16/zh/docs/dev/table/tableapi/)说明了所有流处理和批处理支持的Table API算子。下面的例子是一个简单的Table API聚合查询的例子:
```java
// get a TableEnvironment
TableEnvironment tableEnv = ...; // see "Create a TableEnvironment" section

// register Orders table

// scan registered Orders table
Table orders = tableEnv.from("Orders");
// compute revenue for all customers from France
Table revenue = orders
  .filter($("cCountry").isEqual("FRANCE"))
  .groupBy($("cID"), $("cName"))
  .select($("cID"), $("cName"), $("revenue").sum().as("revSum"));
// emit or convert Table
// execute query
```
### SQL
Flink SQL是基于实现了SQL标准的Apache Calcite，SQL查询由常规字符串指定。文档[SQL]描述了Flink对流处理和批处理表的SQL支持，下面的例子是指定查询并将结果作为Table对象返回。
```java
// get a TableEnvironment
TableEnvironment tableEnv = ...; // see "Create a TableEnvironment" section
// register Orders table

// compute revenue for all customers from France
Table revenue = tableEnv.sqlQuery(
    "SELECT cID, cName, SUM(revenue) AS revSum " +
    "FROM Orders " +
    "WHERE cCountry = 'FRANCE' " +
    "GROUP BY cID, cName"
  );

// emit or convert Table
// execute query
```
下面的例子指定了一个更新查询，并将查询的结果插入到已注册的表中:
```java
// get a TableEnvironment
TableEnvironment tableEnv = ...; // see "Create a TableEnvironment" section

// register "Orders" table
// register "RevenueFrance" output table

// compute revenue for all customers from France and emit to "RevenueFrance"
tableEnv.executeSql(
    "INSERT INTO RevenueFrance " +
    "SELECT cID, cName, SUM(revenue) AS revSum " +
    "FROM Orders " +
    "WHERE cCountry = 'FRANCE' " +
    "GROUP BY cID, cName"
  );
```
## 混用Table API和SQL
Table API和SQL查询的混用非常简单，因为都返回Table对象:
- 可以在SQL查询返回的Table对象上定义Table API查询;
- 在TableEnvironment中注册的结果表可以在SQL查询的FROM子句中引用。

## 输出表

# 第一章 引论
## 本书讨论的内容

# 第二章 算法分析
# 第10章 算法设计技巧
本章讨论用于求解问题的5种通常类型的算法，对于很对问题，这些方法中至少有一种是可以解决问题的。
## 贪婪算法
greedy algorithm，Dijkstra算法、Prim算法、Kruskal算法都是贪婪算法，贪婪算法分阶段的工作，每一个阶段都做最好的决定而不考虑整体，局部最优=全局最优，那么算法就是正确的，否则算法会得到一个次最优解，如果不要求绝对最佳答案，那么贪婪算法需要的计算可能比计算准确答案要简单很多。贪婪算法的例子比如钱币找零问题。
1. 一个简单的调度问题
有作业$j_1,j_2,...,j_N$，已知对应的运行时间分别是$t_1,t_2,...,t_N$，处理器只有一个，求作业平均完成时间的最小化，事实证明作业是按照最短作业最先进行，平均时间最小，证明如下,第一个作业以$t_1$时间完成，第二个作业以$t_1+t_2$时间完成，第三个作业以$t_1+t_2+t_3$时间完成，得到总的时间$C$如下:
$$ C=\sum ^{N}_{k=1} \left ( {N-k+1} \right ){t}_{k} $$
拆分公式得到
$$ C=\left ( {N+1} \right )\sum ^{N}_{k=1} {{t}_{k}}-\sum ^{N}_{k=1} {k}\cdot {t}_{k} $$
第一个和与作业的排序无关，只有第二个影响到总开销，第二个越大，则总开销越小，假如存在$x>y$使得$t_x<t_y$，
经过计算此时交换$t_x$与$t_y$第二个和增加，从而降低总开销，因此，所用时间不是单调非减的任何的作业调度都是次最优的，这个结果指出操作系统调度程序一般把优先权赋予那些更短作业的原因。
2. 哈夫曼编码
贪婪算法的第二个应用文件压缩，ASCII字符集包含100个左右的字符，所以需要至少需要$⌈log 100⌉=7$个bit，第8个bit作为奇偶校验位，如果字符集的大小是$C$那么标准的编码中就需要$⌈log C⌉$个bit，假设一个文件的字符信息如下:

|字符|编码|频率|bit数|
|:---|:---|:---|:---|
|a|000|10|30|
|e|001|15|45|
|i|010|12|36|
|s|011|3|9|
|t|100|4|12|
|空格|101|13|39|
|newline|110|1|3|
这个文件需要174个bit来表示，网络传输与磁盘存储需要更少的bit数，而不同的字符的出现频率是不同的，根绝这个特点，只要保证常出现的字符的bit短就能有效的减少总的传输量，
字符的二进制代码可以用二叉树表示0表示左分支，1表示右分支，如下图所示
![字符二叉树](adtjava/trie-%E7%AC%AC%201%20%E9%A1%B5.drawio.png)
现在就是要减少到每个叶节点的路径长度，比如nl字符它是仅有的儿子，可以放到上一层，减少一层
![字符二叉树](adtjava/trie-%E7%AC%AC%202%20%E9%A1%B5.drawio.png)
这是一颗满树，最优的编码总是满树，要不是叶节点，要不具有2个儿子，具有一个儿子的可以向上移动一层。
只要字符都在叶节点上，那么就可以正常的译码，如果放在非叶节点上，那么字符的前缀可能会是别的字符，存在二义性，只要字符代码不是别的字符代码的前缀，那么字符编码的长度无关紧要，这样的编码就做前缀码。构造前缀码的一个算法就是哈夫曼编码，算法的过程如下:
设字符的个数位$C$，算法的数据是由多个树组成的森林，初始为$C$颗单节点树，每个字符一颗，初始的树的权就是字符频率，任意选取最小权的2颗树，$T_1$与$T_2$组成新的树，新的树的权等于2个子树的权的和，重复步骤$C-1$次，算法结束时得到一颗树，这棵树就是最优哈夫曼编码树。
在压缩文件的开头要传送编码信息，否则不可能译码。
2. 近似装箱问题
装箱问题可以产生距离最优解不远的解。设有$N$个箱子，大小分别为$s_1,s_2,...,s_N$，每个都满足$0<s_i<1$，把他们装到容量为1大箱子中去，求一种使用箱子最少的办法。有2种版本的装箱问题。

- 联机装箱问题，on-line bin packing problem，每一个物品必须放入一个箱子后才能处理下一个物品;
- 脱机装箱问题，off-line bin packing problem, 做任何事都需要把所有的输入数据全部读取完后才进行;
1. 联机算法
联机算法并不能总给出最优解，考虑权为$ \frac {1} {2}-\varepsilon$的$M$个小项与权为$ \frac {1} {2}+\varepsilon$的$M$个大项构成的序列$I_1$，其中$0<\varepsilon<1$，如果每个箱子中放一个小项与一个大项，那么可以放入到$M$个箱子中去，假设存在一个最优的联机装箱算法$A$，考虑对序列$I_2$操作，该序列只有$ \frac {1} {2}-\varepsilon$的$M$个小项组成，$I_2$是可以装入到$ \lceil M/2\rceil  $个箱子中去，不知道这个在讲什么？fuck。
> 定理10.1: 存在使得任意联机装箱算法至少使用$ \frac {4} {3}$最优箱子数的输入

- 下项适合算法（next fit），当处理任何一件物品时，检查它是否还能装进刚刚装进物品的同一个箱子中去，如果可以就放进去，不行就开辟新的箱子
> 定理10.2: 令$M$是将一列物品$I$装箱所需的最优装箱数，则下项适合算法所有箱子数绝不超过$2M$个箱子，存在一些顺序使得下项适合算法用箱子数达到$2M-2$个

- 首次适合算法(first fit)，依次扫描箱子，并把新的物品放入碰到的第一个能够放入它的箱子，如果没有则开辟新的箱子
> 定理10.3: 令$M$是将一列物品$I$装箱所需的最优装箱数，则首次适合算法所有箱子数绝不超过$\lceil \frac {17} {10}M \rceil$个箱子，存在一些顺序使得首次适合算法用箱子数达到$\lceil \frac {17} {10}(M-1) \rceil$个

- 最佳适合算法(best fit)，一个新的物品找到能放入它的最满的箱子中去，也就是剩余空间最小的那个箱子中去，
2. 脱机算法
首次适合非增算法，前提是物品按照权重已经排序。

## 分治算法



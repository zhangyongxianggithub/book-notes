软件架构师有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。软件架构会包括软件组件、组件之间的关系、组件的特性以及组件见关系的特性。软件架构可以和建筑物的架构相比拟。软件架构是构建计算机软件、开发系统以及计划进行的基础，可以列出开发团队需要完成的任务。软件架构是在软件的基础架构上进行决策，决定后再做修改的代价很大。软件架构中的决策包括在软件设计时的一些特殊结构性选项，例如要控制太空船登陆艇的系统需要快速而且可靠，因此需要选择适合实时计算的语言，而且为了满足可靠度的需求，程序需要有数个冗余的复本，各复本运作在不通的硬件上，以便比对各程序的结果。将软件架构文档化有助于和利益攸关方沟通，在高层设计时就可以提早进行决策，也可以在各项目之间复用设计组件。
# 介绍
软件体系结构是构建计算机软件实践的基础。与建筑师设定建筑项目的设计原则和目标一样，作为绘图员画图的基础一样，软件架构师或者系统架构师陈述软件架构以作为满足不同客户需求的实际系统设计方案的基础。从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。一个软件架构师需要有广泛的软件理论知识和相应的经验来实施和管理软件产品的高级设计。软件架构师定义和设计软件的模块化，模块之间的交互，用户界面风格，对外接口方法，创新的设计特性，以及高层事物的对象操作、逻辑和流程。软件架构师于客户商谈概念上的事情，与经理商谈广泛的设计问题，与软件工程师商谈创新的结构特性，与程序员商谈实现技巧，外观和风格。软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件、各个组件之间的连接、相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。
# 范围
软件架构的范围有许多不同的定义:
- 宏观系统架构: 这是指架构作为软件系统的高级抽象，由计算组件的集合以及描述这些组件之间交互的连接器组成;
- 重要的事情，无论是什么: 指的是，软件架构应该关注对系统与利益相关者有重大影响的决策;
- 了解系统及其背景的基础东西
- 人们认为不会轻易改变的事情: 由于设计架构是在软件系统生命周期的开始阶段进行的，因此架构师应该专注于必须第一次就正确的决策。按照这个思路，一旦有些问题是可逆的，软件架构上的问题就可以转换为非架构性的问题
- 许多的架构设计决策: 软件架构不应仅仅被视为一组模型或结构，而应包括导致这些特性结构的决策及其背后的基本原理。这种见解引发了对软件架构知识管理的大量研究

在软件架构、设计】需求工程之间，没有具体明显的分界。这些是一连串意图的结合，从高阶的设计意向到低端的设计细节。
# 特点
软件架构的特点如下:
- 大量的利益攸关方: 软件系统必须满足各种各样的利益相关方的要求。这些利益攸关方包括业务经理、部门主管、用户与运营商。这些利益攸关方每个都有各自关注的内容。平衡这些关注点并证明它们已得到解决是设计系统的一部分。这意味着架构涉及处理广泛多样的关注点与各种各样的利益攸关方。具有多种学科的统筹考虑特点
- 关注点分离: 架构师降低复杂性的既定方法是分离驱动设计的关注点，也就是关注点分离。架构文档表明所有的利益攸关方关注点都可以通过建模与架构描述来解决，架构描述要使用与利益相关方关注点相关的不同视图角度来描述。这些单独的描述称为架构视图。
- 质量驱动: 经典的软件设计方法，比如杰克逊结构化编程是由所需的功能和系统中的数据流驱动的，但是软件架构本质是由它的质量属性驱动的，比如容错性、向后兼容性、可扩展性、可靠性、可维护性、可用性、安全性、复用性等。利益相关方的关注点通常会转化为对这些质量属性的需求，这些需求称为非功能性需求、额外的功能需求、行为需求或者质量属性需求
- 架构风格: 与建筑体系结构一样，软件架构学科也开发了标准方法来解决重复出现的问题，这些标准方法在不同的抽象层次上有不同的名称。重复出现的解决方案的常用术语叫做架构风格、架构策略、参考架构或者叫做架构模式
- 概念完整性: Fred Brooks在其1975年出版的《人月神话》一书中引入了这个术语，表示软件系统的架构代表了它应该做什么以及如何做的总体概括。这个概括应该与其实施分开。架构师承担“概括守护者”的角色，确保系统的添加符合架构，从而保持概念的完整性。
- 认知约束: 计算机程序员梅尔文·康威 (Melvin Conway) 在1967年的一篇论文中首次提出了一个观察结果，即设计系统的组织被迫生产一种设计，这种设计是这些组织的通信结构的copy。与概念完整性一样，弗雷德·布鲁克斯在他优雅的经典著作《人月神话》中引用这篇论文和这个想法时，将其介绍给了更广泛的受众，并将其称为“康威定律”。

# 动机
软件架构是一个对复杂系统智力理解抽象，也就是逻辑理解抽象。此后像有以下的好处:
- 它为在系统构建之前分析软件系统的行为提供了基础，无需实际构建即可验证未来软件系统是否满足利益攸关者需求，还可以验证成本约束与风险控制等。已经开发了许多技术来执行此类分析，例如 ATAM 或创建软件系统的可视化表示。
- 它为元素和决策的重用提供了基础。完整的软件架构或其中的一部分（例如单独的架构策略和决策）可以在利益相关者要求相似质量属性或者功能的多个系统中重用，节省设计成本并降低设计错误的风险
- 它支持做出影响系统开发、部署和维护寿命的早期重要设计决策。做出正确的、高影响力的早期决策对于防止进度和预算超支非常重要。
- 它促进与利益攸关方的沟通，有助于建立一个更好地满足其需求的系统。从利益相关者的角度就复杂系统进行沟通，有助于他们理解其既定需求以及基于这些需求的设计决策的后果。架构提供了在系统实施之前就设计决策进行沟通的能力，此时设计决策仍然相对容易调整。
- 有助于风险管理。软件架构可以减少风险以及失败的几率
- 可以降低成本。软件架构是一种管理复杂IT计划风险以及成本的方式

# 历史
软件设计和（民用）架构之间的比较最初是在20世纪60年代末期进行的，但"软件架构"一词直到20世纪90年代才得到广泛使用。计算机科学领域自形成以来就遇到了与复杂性相关的问题。开发人员通过选择正确的数据结构、开发算法以及应用关注点分离的概念来解决早期的复杂性问题。尽管"软件架构"这个术语对于业界来说相对较新，但自20世纪80年代中期以来，软件工程先驱们已经零星地应用了该领域的基本原理。早期尝试捕获和解释系统的软件架构是不精确且杂乱的，通常以一组箱线图为特征。
软件架构作为一个概念起源于1968年Edsger Dijkstra和20世纪70年代初David Parnas的研究。这些科学家强调，软件系统的结构很重要，正确的结构至关重要。在20世纪90年代，人们齐心协力定义和编纂该学科的基本方面，研究工作集中在架构风格（模式）、架构描述语言、架构文档和形式化方法上。
研究机构在推动软件架构作为一门学科的发展方面发挥了突出的作用。卡内基梅隆大学的Mary Shaw和David Garlan在1996年写了一本名为《软件架构：新兴学科的观点》的书，推广了组件、连接器和样式等软件架构概念。加州大学欧文分校软件研究所在软件架构研究方面的工作主要集中在架构风格、架构描述语言和动态架构方面。
IEEE 1471-2000，《软件密集型系统架构描述的推荐实践》，是软件架构领域的第一个正式标准。它于2007年被ISO采纳为ISO/IEC 42010:2007。 2011年11月，IEEE 1471–2000被ISO/IEC/IEEE 42010:2011《系统和软件工程 – 架构描述》（由IEEE和ISO联合出版）取代。
而在IEEE 1471中，软件架构是关于“软件密集型系统”的架构，定义为"软件对整个系统的设计、构建、部署和演进产生重要影响的任何系统"，2011年版 更进一步，纳入了ISO/IEC 15288和ISO/IEC 12207系统定义，其中不仅包括硬件和软件，还包括“人员、流程、程序、设施、材料和自然存在的实体”。 这体现了软件架构、企业架构和解决方案架构之间的关系

# 架构活动
软件架构师要做很多事，软件架构师通常与项目经理合作、与利益攸关方讨论架构上的重要需求、设计软件架构、评估设计、与设计师和利益相关方沟通、记录架构设计等。软件架构设计有4个核心活动。这些核心架构活动是在初始软件开发生命周期的不同阶段以及系统的演进过程中迭代执行的。
- Architectural analysis: 架构分析是理解一个预期系统如何在一个环境中运行并确定系统需求的过程。分析活动的输入或要求可以来自任意数量的利益相关者，包括以下项目:
  - 系统运行时将会做什么，功能性需求
  - 系统对运行时的非功能性需求解决的怎么样，比如可靠性、可操作性、性能效率、安全性、兼容性，这些非功能性需求定义在ISO/IEC 25010:2011标准中
  - 非功能性需求比如可维护性、转移性的开发时间
  - 系统的业务需求和环境背景可能会随着时间的推移而变化，例如法律、社会、财务、竞争和技术问题
  
  分析活动的输出是那些对软件系统架构有可衡量影响的需求，称为架构上的重要需求

- Architectural synthesis: 架构综合或者设计是创建架构的过程。根据分析确定的架构上的重要要求、设计的当前状态以及任何评估活动的结果。创建并改进设计
- Architecture evaluation: 架构评估是确定当前设计或其一部分在多大程度上满足分析过程中得出的要求的过程。每当架构师考虑设计决策时，都可以进行评估，可以在设计的某些部分完成后进行，也可以在最终设计完成后进行，也可以在系统构建完成后进行。一些可用的软件架构评估技术包括架构权衡分析方法(ATAM)和TARA。SARA报告和架构评论：实践和经验等框架中讨论了用于比较技术的框架
- Architecture evolution: 架构演进是维护和调整现有软件架构以满足需求和环境变化的过程。软件架构提供了软件系统的基础结构，其演化和维护必然会影响其基础结构。 因此，架构演进涉及添加新功能以及维护现有功能和系统行为

架构设计需要关键的支持活动，这些支持活动贯穿整个核心软件架构流程。它们包括知识管理和沟通、设计推理和决策以及文档。

## Architecture supporting activities
软件架构支持活动是在核心软件架构活动期间进行的。这些支持活动帮助软件架构师进行分析、设计、评估和演化。例如，架构师必须在分析阶段收集知识、做出决策并记录。
- Knowledge management and communication: 知识管理和沟通是探索和管理知识的行为，这些知识都是对于设计软件架构至关重要的。软件架构师并不是孤立的工作，他们从各个利益相关者那里获取输入、功能和非功能性需求以及设计背景；并向利益攸关方提供产出。软件架构知识通常是隐性的保留在利益相关者的头脑中。软件架构知识管理活动是关于发现、交流和保留知识。由于软件架构设计问题错综复杂且相互依赖，设计推理中的知识gap可能会导致不正确的软件架构设计。知识管理和交流活动的示例包括搜索设计模式、原型设计、询问经验丰富的开发人员和架构师、评估类似系统的设计、与其他设计人员和利益相关者共享知识以及在wiki页面上记录经验。
- Design reasoning and decision making: 设计推理与决策是评估设计决策的活动。此活动是所有3个核心软件架构活动的基础。它需要收集和关联决策背景、制定设计决策问题、寻找解决方案选项并在做出决策前评估权衡。该过程发生在不同级别的决策粒度上，同时评估重要的架构需求和软件架构决策，以及软件架构分析、综合和评估。 推理活动的示例包括了解需求或设计对质量属性的影响、质疑设计可能引起的问题、评估可能的解决方案选项以及评估解决方案之间的权衡。
- Documentation: 文档是记录软件架构过程中生成的设计的行为。系统设计是使用多种视图来描述的。这些视图通常包括:
  - 显示系统代码结构的静态视图
  - 显示运行中系统行为的动态视图
  - 显示系统如何安放在硬件上用于运行的开发视图
  
  Kruchten的4+1视图提出了用于记录软件架构的常用视图的描述，记录软件架构: 视图及超越描述了可在视图描述中使用的符号类型。文档活动的示例包括编写规范、记录系统设计模型、记录设计原理、开发观点、记录视图。

# Software architecture topics
## Software architecture description
软件架构描述涉及使用架构描述语言、架构观点和架构框架等机制来建模和表示架构的原理和实践。
## Architecture description languages
架构描述语言(ADL)是用于描述软件架构的任何表达方式(ISO/IEC/IEEE 42010)。自20世纪90年代以来，已经开发了许多特殊用途的ADL，包括AADL（SAE标准）、Wright（由卡内基梅隆大学开发）、Acme（由卡内基梅隆大学开发）、xADL（由UCI开发）、Darwin（由伦敦帝国理工学院开发） 、DAOP-ADL（马拉加大学开发）、SBC-ADL（国立中山大学开发）和ByADL（意大利拉奎拉大学）。
## Architecture viewpoints
软件架构描述通常被组织称视图。这类似建筑架构中的不同类型的蓝图，每个视图都遵循其视点的约定来解决一组系统问题，其中视点是一种规范，描述在视图中使用的符号、建模和分析技术，视图表明了从利益攸关方的角度思考的问题与关切。视点不仅指定了所关注的问题（即要解决的问题），还指定了表示方式、使用的模型类型、使用的约定以及任何一致性（对应）规则，以保持视图与其他视图一致。
## Architecture frameworks
一个架构框架指的是用于架构描述的约定、原则与实践。这些架构描述建立在一个特定应用或者利益攸关方社区的领域内，框架通常根据一个或多个观点或 ADL来实现。
## Architectural styles and patterns
架构模式是一个通用的可复用的解决方案。用来解决软件架构中的一些通用的问题。架构模式也称作软件设计模式。与传统的建筑架构概念类似，软件架构风格也是一种特定的建构方法，风格的主要特色就是那些明显的特征决定的。架构风格定义: 就结构组织模式而言的一系列系统；组件和连接器的词汇表，以及如何组合它们的限制。架构风格是可重复使用的设计决策和约束的包，它们应用于架构以产生所选择的所需质量属性。
有许多知名的架构模式及风格，举例如下:
- [Blackboard](https://en.wikipedia.org/wiki/Blackboard_(design_pattern))
- [Client-Server](https://en.wikipedia.org/wiki/Client%E2%80%93server_model)(2-tier, 3-tier, n-tier, cloud computing exhibit this style)
- [Component-based](https://en.wikipedia.org/wiki/Software_componentry)
- [Data-Centric](https://en.wikipedia.org/wiki/Database-centric_architecture)
- [Event-Driven](https://en.wikipedia.org/wiki/Event-driven_architecture) or [implicit invocation](https://en.wikipedia.org/wiki/Implicit_invocation)
- [Layered](https://en.wikipedia.org/wiki/Abstraction_(computer_science)#Layered_architecture) or [multilayered architecture](https://en.wikipedia.org/wiki/Multilayered_architecture)
- [Microservices architecture](https://en.wikipedia.org/wiki/Microservices)
- [Monolithic application](https://en.wikipedia.org/wiki/Monolithic_application)
- [Peer-to-peer](https://en.wikipedia.org/wiki/Peer-to-peer)
- [Pipes and filters](https://en.wikipedia.org/wiki/Pipes_and_filters)
- [Plug-ins](https://en.wikipedia.org/wiki/Plug-in_(computing))
- [Reactive Architecture](https://en.wikipedia.org/w/index.php?title=Reactive_architecture&action=edit&redlink=1)
- [Representational state transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)(REST)
- [Rule-based](https://en.wikipedia.org/wiki/Rule-based_system)
- [Service-oriented](https://en.wikipedia.org/wiki/Service-oriented_architecture)
- [Shared nothing architecture](https://en.wikipedia.org/wiki/Shared_nothing_architecture)
- [Space-based architecture](https://en.wikipedia.org/wiki/Space-based_architecture)
- Serverless architecture

有些人将架构模式pattern与架构风格style视为相同的东西。有些人将架构风格视为特定的架构模式。它们的共同点是模式和风格都是架构师使用的惯用语，它们提供了一种通用语言或词汇来描述某类系统。
## Software architecture and agile development
还有人担心软件架构会导致过多的前期大设计，尤其是敏捷软件开发的支持者。人们已经开发了许多方法来平衡前期设计和敏捷开发，包括敏捷方法 DSDM，它要求一个基础阶段，在此阶段奠定刚好足够的架构基础。IEEE Software专门出了一期关于敏捷性和架构之间的相互作用的特刊。
## Software architecture erosion
软件架构腐蚀或者也叫做decay，软件架构侵蚀是指在软件系统的实现中所实现的计划架构与实际架构之间观察到的差距。当实施决策未完全实现计划的架构或违反该架构的约束或原则时，就会发生软件架构侵蚀。例如: 考虑一个严格分层的系统，其中每一层只能使用紧接其下一层提供的服务。任何不遵守此约束的源代码组件都表示违反体系结构。如果不加以纠正，此类违规行为可能会将架构转变为整体块，从而对可理解性、可维护性和可演化性产生不利影响。已经提出了各种方法来解决侵蚀问题。这些方法，包括工具、技术和流程，主要分为三大类，试图最大限度地减少、防止和修复架构侵蚀。在这些大类中，每种方法都进一步细分，反映了为减少架构侵蚀而采取的高层策略。解决侵蚀问题。这些是面向流程的架构一致性、架构演进管理、架构设计实施、架构与实现的链接、自适应以及由恢复、发现和协调组成的架构恢复技术。有两种主要技术可以检测架构违规：反射模型和特定于领域的语言。反射模型 (RM) 技术将系统架构师提供的高级模型与源代码实现进行比较。还有一些特定于领域的语言，重点是指定和检查架构约束。
## Software architecture recovery
软件架构恢复（重建、逆向工程）包括从可用信息（包括其实现源代码和文档）中总结出软件系统架构的方法、技术和过程。面对废弃的或者过时的文档与架构侵蚀，架构恢复通常是做出明智决策所必需的：实现和维护决策偏离了设想的架构。一种实践是将软件架构恢复当做静态程序分析。这是软件智能实践所涵盖的主题的一部分。
# Related Fields
## Design
架构是设计但是不是所有的设计都是架构。在实践中，架构师是在软件架构(架构设计)和详细设计(非架构设计)之间划清界线的人。尽管已经尝试将这种区别正式化，但没有适合所有情况的规则或指南。根据Intension/Locality假说，架构设计和详细设计之间的区别是由局部性准则定义的，根据该准则，有关软件设计的声明是非局部（架构）的，当且仅当一个程序 满足则可以扩展为不满足的程序。例如，客户端-服务器风格是架构性的（战略性的），因为基于此原则构建的程序可以扩展为非客户端-服务器的程序，例如通过添加对等节点。
## Requirements engineering
需求工程和软件工程可以被视为互补的方法: 软件架构的目标是"解决方案空间"(solution space)或"如何"，需求工程则解决"问题空间"(problem space)或"what"。需求工程涉及需求的获取、协商、规范、验证、文档化与需求管理。需求工程和软件架构都围绕利益攸关者的关注点、需求与愿望。需求工程与软件架构之间存在相当大的重叠。例如对五种工业软件架构方法的研究就证明了这一点，该方法得出的结论是“输入（目标、约束等）通常定义不明确，只能被发现或更好” 当架构开始出现时就可以理解”，并且虽然"大多数架构问题都表达为对系统的需求，但它们也可以包括强制的设计决策"。简而言之，所需的行为会影响解决方案架构，进而可能引入新的需求。双峰模型等方法旨在利用需求和架构之间的协同关系。
## Other types of 架构
- Computer Architecture: 计算机架构指的是计算机系统的内部结构，包括CPU(或处理器)、总线和内存等硬件组件的协作
- Serverless architecture: 无服务架构是一种云计算范例，经常被曲解为无服务器。它本质上是将服务器管理指责从开发人员转移到了云服务提供商。这使得企业可以在云基础设施上运行后端代码，从而无需物理服务器管理。无服务架构的事件驱动方法依赖于按需执行的小型、特定任务的函数。这些功能被称为函数即服务 (FaaS)，它们通过即用即付计费模型和基于应用程序需求的动态资源扩展来提供成本效益
- Systems architecture: 术语系统架构最初指的是由硬件和软件组成的系统架构。系统架构解决的主要问题是将软件和硬件集成到一个完整、正确工作的设备中。在另一个常见的（更广泛的）含义中，该术语指的是任何可能具有技术、社会技术或社会性质的复杂系统的架构。
- Enterprise architecture: 企业架构的目标是将业务愿景和战略转化为有效的企业。企业架构框架，例如TOGAF和Zachman框架，通常区分不同的企业架构层。尽管术语因框架而异，但许多框架至少包括业务层、应用程序（或信息）层和技术层之间的区别。 企业架构通常采用自上而下的方法解决这些层之间的一致性问题。
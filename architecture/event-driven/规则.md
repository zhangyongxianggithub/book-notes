规则由JSON定义
```json
{
  "id": "rule1",
  "sql": "SELECT demo.temperature, demo1.temp FROM demo left join demo1 on demo.timestamp = demo1.timestamp where demo.temperature > demo1.temp GROUP BY demo.temperature, HOPPINGWINDOW(ss, 20, 10)",
  "actions": [
    {
      "log": {}
    },
    {
      "mqtt": {
        "server": "tcp://47.52.67.87:1883",
        "topic": "demoSink"
      }
    }
  ]
}
```
| **参数名** | **是否可选**              | **说明**                           |
|---------|-----------------------|----------------------------------|
| id      | 否                     | 规则 id, 规则 id 在同一 eKuiper 实例中必须唯一 |
| name    | 是                     | 规则显示的名字或者描述                      |
| sql     | 如果 graph 未定义，则该属性必须定义 | 为规则运行的 sql 查询                    |
| actions | 如果 graph 未定义，则该属性必须定义 | Sink 动作数组                        |
| graph   | 如果 sql 未定义，则该属性必须定义   | 规则有向无环图的 JSON 表示                 |
| options | 是                     | 选项列表                             |

一个规则代表了一个流处理流程，定义了从将数据输入流的数据源到各种处理逻辑，再到将数据输入到外部系统的动作。有两种方法来定义规则的业务逻辑。要么使用SQL/动作组合，要么使用新增加的图API。选项支持:

| **选项名**            | **类型和默认值** | **说明 **                                                                                         |
|--------------------|------------|-------------------------------------------------------------------------------------------------|
| isEventTime        | bool:false | 使用事件时间还是将时间用作事件的时间戳。 如果使用事件时间，则将从有效负载中提取时间戳。 必须通过 stream 定义指定时间戳记。                              |
| lateTolerance      | int64:0    | 在使用事件时间窗口时，可能会出现元素延迟到达的情况。 LateTolerance 可以指定在删除元素之前可以延迟多少时间（单位为 ms）。 默认情况下，该值为0，表示后期元素将被删除。    |
| concurrency        | int: 1     | 一条规则运行时会根据 sql 语句分解成多个 plan 运行。该参数设置每个 plan 运行的线程数。该参数值大于1时，消息处理顺序可能无法保证。                       |
| bufferLength       | int: 1024  | 指定每个 plan 可缓存消息数。若缓存消息数超过此限制，plan 将阻塞消息接收，直到缓存消息被消费使得缓存消息数目小于限制为止。此选项值越大，则消息吞吐能力越强，但是内存占用也会越多。  |
| sendMetaToSink     | bool:false | 指定是否将事件的元数据发送到目标。 如果为 true，则目标可以获取元数据信息。                                                        |
| sendError          | bool: true | 指定是否将运行时错误发送到目标。如果为 true，则错误会在整个流中传递直到目标。否则，错误会被忽略，仅打印到日志中。                                     |
| qos                | int:0      | 指定流的 qos。 值为0对应最多一次； 1对应至少一次，2对应恰好一次。 如果 qos 大于0，将激活检查点机制以定期保存状态，以便可以从错误中恢复规则。                  |
| checkpointInterval | int:300000 | 指定触发检查点的时间间隔（单位为 ms）。 仅当 qos 大于0时才有效。                                                           |
| restartStrategy    | 结构         | 指定规则运行失败后自动重新启动规则的策略。这可以帮助从可恢复的故障中回复，而无需手动操作。请查看规则重启策略了解详细的配置项目。                                |

# 规则管道
我们可以通过将先前规则的结果导入后续规则来形成规则管道。 这可以通过使用中间存储或 MQ（例如 mqtt 消息服务器）来实现。 通过同时使用 内存源 和 目标，我们可以创建没有外部依赖的规则管道。规则管道将是隐式的。 每个规则都可以使用一个内存目标/源。 这意味着每个步骤将使用现有的 api 单独创建（示例如下所示）。
```json
#1 创建源流
{"sql" : "create stream demo () WITH (DATASOURCE=\"demo\", FORMAT=\"JSON\")"}

#2 创建规则和内存目标
{
  "id": "rule1",
  "sql": "SELECT * FROM demo WHERE isNull(temperature)=false",
  "actions": [{
    "log": {
    },
    "memory": {
      "topic": "home/ch1/sensor1"
    }
  }]
}

#3 从内存主题创建一个流
{"sql" : "create stream sensor1 () WITH (DATASOURCE=\"home/+/sensor1\", FORMAT=\"JSON\", TYPE=\"memory\")"}

#4 从内存主题创建另一个要使用的规则
{
  "id": "rule2-1",
  "sql": "SELECT avg(temperature) FROM sensor1 GROUP BY CountWindow(10)",
  "actions": [{
    "log": {
    },
    "memory": {
      "topic": "analytic/sensors"
    }
  }]
}

{
  "id": "rule2-2",
  "sql": "SELECT temperature + 273.15 as k FROM sensor1",
  "actions": [{
    "log": {
    }
  }]
}
```
通过使用内存主题作为桥梁，我们现在创建一个规则管道：rule1->{rule2-1, rule2-2}。管道可以是多对多的，而且非常灵活。请注意，内存目标可以与其他目标一起使用，为一个规则创建多个规则动作。并且内存源主题可以使用通配符订阅过滤后的主题列表。
# 状态与容错
eKuiper支持有状态的规则流，有2种状态:
- 窗口操作和可回溯源的内部状态
- 对流上下文扩展公开的用户状态，可以参考状态存储。

默认情况下，所有状态仅驻留在内存中，这意味着如果流异常退出，则状态将消失。为了使状态容错，Kuipler 需要将状态检查点放入永久性存储中，以便在发生错误后恢复。将规则选项qos设置为1或2将启用检查点。通过设置 checkpointInterval选项配置检查点间隔时间。当在流处理应用程序中出现问题时，可能会造成结果丢失或重复。 对于qos的3个选项，其对应行为将是：
- 最多一次（0）：eKuiper 不会采取任何行动从问题中恢复
- 至少一次（1）：没有任何结果丢失，但是您可能会遇到重复的结果
- 恰好一次（2）：没有丢失或重复任何结果

考虑到eKuiper通过回溯和重播源数据流从错误中恢复，将理想情况描述为恰好一次时，并不意味着每个事件都会被恰好处理一次。 相反，这意味着每个事件将只会对由eKuiper管理的状态造成一次影响。如果您不需要“恰好一次”，则可以通过使用AT_LEAST_ONCE配置eKuiper，进而获得一些更好的效果。
# 推荐序一
- 普通程序猿，了解程序语言特性，能够正确的实现业务逻辑与数据流程等
- 工程师，使代码易读、易扩展、易维护、可重用
- 架构师，解决复杂系统的问题，技术与业务综合的权衡。问题的多少与系统的复杂度成正比

>无论是微观世界的代码还是宏观层面的架构，无论是3种编程范式还是微服务架构，他们都在解决一个问题--分离控制与逻辑。所谓控制就是对程序流转的与业务逻辑无关的代码或系统的控制，比如多线程、异步、服务发现、部署、弹性伸缩，所谓逻辑则是实实在在的业务逻辑，是解决用户问题的逻辑，控制和逻辑构成了整体的软件复杂度，有效的分离控制和逻辑会让你的系统得到最大的简化

>如果你要成为一名架构师，你需要明确的区分几组词语，否则你不可能成为一名合格的工程师或者架构师。这几组词语是简单vs简陋、平衡vs妥协、迭代vs半成品。如果你不能很清楚的定义出其中的区别。那么你将很难做出正确的决定，也就不可能成为一名优秀的工程师或者架构师

# 推荐序二
# 序言
- 软件架构学关注的一个重点是组织架构
- 软件项目是具有递归和分形特点的
- 软件架构是系统设计过程中的重要设计决定的集合。
# 前言
Bob大叔的经验就是实际构建一些大大小小的软件系统。软件架构的规则是相同的，计算机代码没变，软件架构规则也没变，就是排列组合代码块的规则。

# 第一部分 概述
写出可运行的代码并不难，只是初级程序员的基本要求。软件架构设计难做，需要一定的知识、技能，需要自律与专注。带来的收益很大，软件变得易于扩展，需要投入巨大的人力与维护成本。
# 第1章 设计与架构究竟是什么
架构等于设计。底层设计信息构成了顶层架构设计。
## 目标是什么
软件架构的终极目标是用最小的人力成本来满足构建和维护系统的需求。
乱麻系统
- 没有经过设计，匆忙开发出来的
- 为了加快发布的速度，拼命添加新人
- 决策层对代码质量/设计结构优化忽视

软件研发人员会持续低估那些好的、良好设计的、整洁代码的重要性。2个错误观点
- 我们可以未来再重构代码，产品上线最重要
- 在工程中容忍糟糕的代码存在可以在短期内加快该工程上线的速度，未来这些代码会造成一些额外的工作量，但是没有什么大不了

要想跑得快先要跑的稳
## 本章小结
# 第2章 2个价值维度
软件的价值体现在行为与架构2个方面
1. 行为价值
软件系统的行为是其最直观的价值维度。就是系统的功能，当前的运行行为，已满足使用者的需求为目标，就是不管怎么实现
2. 架构价值
软件发明的目的就是以一种灵活的方式改变机器的工作行为，很难改变的工作行为，称之为硬件。所以软件要足够灵活。架构价值就是当前的系统是否易于修改扩展变更

紧急的难题永远是不重要的，重要的难题永远是不紧急的。
- 系统行为是紧急的，并不总是特别重要
- 系统架构是重要的，但是并不总是特别紧急

软件架构师关注系统的整体架构而不是具体的功能和系统行为的实现。软件架构师必须创建出一个可以让功能实现起来更容易、修改起来更简单、扩展起来更轻松的软件架构。

# 第二部分 从基础构件开始: 编程范式
程序的编写模式
# 第3章 编程范式总览
1. 结构化编程，structured programming，对程序控制权的直接转移进行了限制与规范
2. 面向对象编程，object-oriented programming，对程序控制权的间接转移进行了限制与规范
3. 函数式编程，function programming，来自于1936年发明的$\lambda$演算，基于这个演算发明了LISP语言，$\lambda$演算法的核心就是不可变性。对程序中的赋值进行了限制与规范

# 第4章 结构化编程
结构化编程可以将模块递归拆分为可推导的单元，分为顺序结构、分之结构与循环结构。结构化编程限制了goto，结构化编程的功能性降解拆分式最佳实践之一。就是不断拆分出底层函数。编程时一个科学而不是数学，没法完全证明其正确性，只要没法证明其不正确就可以认为程序是足够正确的。科学理论与科学定律都是无法被证明的。测试的作用是得出某段程序已经足够实现当前目标这个结论。
# 第5章 面向对象编程
设计一个优秀的软件架构要基于对面向对象设计(Object-Oriented Design)的深入理解及应用。
什么是面向对象
- 数据与函数的组合，面向对象的理论来自于将函数的调用栈迁移到堆区域中。
- 面向对象编程是一种对真实世界进行建模的方式
- 由于采用面向对象方式构建的软件与真实世界的关系更紧密，面向对象编程可以使得软件开发更容易
- 封装(encapsulation)、继承(inheritance)、多态(polymorphism)

1. 封装: 封装数据与函数，封装不能是面向对象语言的特性
2. 继承: 
3. 多态: 多态就是函数指针的一种应用，面向对象语言消除了使用指针实现多态的危险性。可以实现很多高级的功能。程序应该与设备无关就可以在多种设备上实现同样的功能，这就是插件式架构。在多态出现之前，软件的函数调用树都是高层调用底层，首先要把底层的代码include进来，按照控制流逻辑加载对应的源代码文件，上层依赖下层。使用多态后，上层只需要提供接口定义，下层依赖上层的接口定义实现，在源代码层面，下层依赖上层，这个叫做依赖反转，在实际执行层面还是传统的调用树的，只是调用树只有在运行时才知道调用哪个实现，在源代码编写时时是不知道的，这与传统的函数调用树不同。而面向对象语言实现依赖反转就是通过接口实现的。

面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力。这种能力让软件架构师可以构建出某种插件式架构，让高层策略组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立与高层组件的开发与部署。
# 第6章 函数式编程
函数式编程语言中的变量是不可变的。所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。
# 第三部分 设计原则
设计一个好的软件系统，从写整洁的代码开始做起。SOLID原则的主要作用就是如何将数据与函数组织成类，以及如何将这些类链接起来成为程序。这里的类仅仅代表一种数据与函数的分组，不一定就是面向对象的领域。
开发模块级结构的主要目标如下: 
- 使软件可容忍被改动
- 使软件更容易被理解
- 构建可以在多个软件系统中复用的组件

SOLID原则适用模块级编程，紧贴代码逻辑，这些原则可以帮助定义软件架构中的组件与模块。SOLID原则:
- **SRP**: 单一职责原则，基于康威定律(一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部架构)的一个推论，每个软件模块都有且只有一个需要被改变的理由
- **OCP**: 开闭原则，软件系统想要被更容易改变，其设计就必须允许新增代码来修改系统行为而非只能靠修改原来的代码
- **LSP**: 里氏替换原则，如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换
- **ISP**: 接口隔离原则，在设计中避免不必要的依赖
- **DIP**: 依赖反转原则，高层的策略性代码不应该依赖实现底层细节的代码，恰恰相反，实现底层细节的代码应该依赖高层策略性的代码
# 第7章 SPR: 单一职责原则
- 任何一个软件模块都应该有且仅有一个被修改的原因
- 任何一个软件模块都应该只对一个用户或者利益攸关者负责(用户就是修改的原因)
- 任何一个软件模块都应该只对某一类行为者负责

将服务不同行为者的代码进行切分。解决办法
- 数据与函数分离
- Facade设计模式

单一职责原则主要讨论的是函数与类之间的关系。在组件层面上，成为共同闭包原则，在软件架构层面上，用于奠定架构边界的变更轴心。
## 第8章 OCP: 开闭原则
设计良好的软件应该易于扩展同时抗拒修改。一个计算机系统应该在不需要修改的前提下可以轻易的扩展。





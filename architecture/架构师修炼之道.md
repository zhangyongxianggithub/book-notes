# 第1章 成为软件架构师
## 软件架构师要做什么?
- 从工程角度定义问题，与所有人合作，共同定义软件的需求与目标，要关注软件的质量属性，关注那些影响架构设计方向的约束与特性，定义问题的同时考虑架构;
- 分解系统，分配指责，只有把软件系统分解，才能制作出满足质量属性需求的策略；
- 关注大局，与外围环境和谐共生，纵观全局，不能着眼于细节
- 在质量属性之间做出取舍；
- 管理技术债务;
- 提升团队的机构技能;
## 什么是软件架构
软件架构是关于如何组织软件的一系列重大设计决策的集合，旨在实现期望的质量属性和其他软件特性。设计决策影响所有软件的相关方，也决定软件的属性，好的架构满足需要的软件质量属性，抑制或者消除不需要的质量属性.
软件结构定义了软件系统的组织与协调方式，将2个元素以某种关系链接在一起就成为了结构，元素是软件的基本组成部分，关系则描述了元素如何协作完成任务。元素与关系粉3中，可以用来构建架构:
- 模块(module);
- 组件连接器(component & connector);
- 分配(allocation);
下面的例子:

|种类|示例元素|示例关系|
|:---|:---|:---|
|模块|类、包、层、存储过程、模块、配置文件、数据库表|使用、允许使用、依赖|
|组件连接器|对象、连接、线程、进程、层、过滤器|调用、订阅、管道、发布、返回器|
|分配|服务器、传感器、台式机、负载均衡器、团队、用户、Docker容器|运行于、负责、开发、存储、支付|
- 模块结构存在与设计阶段;
- 组件连接器结构在软件运行时出现，运行时，组件可以创建与其他组件的连接、产生新进程以及实例化新对象;
- 分配展示了模块元素与组件连接器之间以及模块的元素与现实的物理元素之间的协同与响应关系。

模块指的是设计阶段的元素，组件则是软件运行时的概念，不同类型的结构适合用来思考不同的系统特性，模块结构考虑可测试性和可维护性，组件连接器结构考虑运行时问题（如可用性与性能），选择架构的结构实际上就是选择你想在软件系统中提升的质量属性，思考架构设计可以确保你设计的软件呢系统能够支持你关心的质量属性，是质量属性让软件独一无二。
## 成为团队的架构师
对每一个项目回顾:
- 利益相关方是谁？主要业务目标是什么?
- 项目的整体解决方案是什么样的?
- 涉及哪些技术?
- 最大的风险是什么？你是如何克服的？
- 如果有机会重新做一遍项目，你会如何改进?
# 开发出色的软件
- 架构将大问题分解为容易处理的小问题，现代软件系统庞大且复杂，架构精确的解释了如何将系统划分为轻巧、独立的小模块还能确保整个系统协同工作，让系统的价值高于各个部分的价值之和;
- 软件架构告诉大家如何协同工作;
- 软件架构为讨论复杂设计提供了基本词汇;
- 软件架构关注的不仅仅是功能;
- 软件架构让你避免犯重大错误;
- 架构让软件更灵活
# 第2章 设计思维基础
架构设计总是一边摸索要解决的问题，一边探求解决方案。以人为本的设计思维，将注意力放在受设计决策影响的人身上。
## 设计思维的4条原则
设计思维是从他人的角度思考问题及其解决方案的一种方式。有4种设计原则(HERT):
- 以人为本(design for human)，设计本身是围绕人开展的工作，要理解利益攸关方的要求，架构师离不开团队，必须于团队一起设计架构；
- 推迟决策(preserve ambiguity)，设计决策必须准确、清晰，模糊的需求设计会毁掉项目，软件架构的目标是安排系统结构，提升期望的质量属性，极简主义架构只关心高优先级的质量属性，除此之外的设计决策都可以悬置，等时机成熟后再决定，要求尽可能推迟那种一旦决定就难以更改的设计决策，特别是细枝末节的设计决策都可以留到后面。
- 善于借鉴(design is redesign)，研究以往的设计，探索其中的规律，可能同样的问题已经有了解决方案，你可以在其基础上开始自己的设计，设计软件架构之前，应该多花点时间研究已有的设计，而不是凭空创造一个新的出来，忽视前人的经验是最低效的架构设计方法之一;
- 化虚为实(make the architecture tangible)，架构中的结构以代码的形式存在，代码不够直观，不适合用来讨论质量属性、组件、设计原理、决策结果之类的问题。呈现架构的方式很多可以画出来，可以制作原型或者简单的模型，人们只有通过感性的认识才会理解和消化架构。
## 运用思维模式
设计软件系统需要我们从不同的角度考虑架构，设计思维模式可以帮助我们在合适的时机关注合适的细节。四种思维模式
- 理解问题: 弄清楚问题，从所有涉及的人员那里获取信息，从各方的需求与自身的工作中达到平衡;
- 探索想法: 尝试各种结构的组合，找到最能满足要求的组合，最终找到解决问题的工程方法，需要研究大量的模式、技术或者开发方法;
- 展示想法: 制作模型，线框图编写文档、展示数据等;
- 评估适用性: 针对不同的场景审视某一架构，检查决策风险等展开评估.
## 思考、动手、检查
![TDC循环](软件工程/TDC循环.png)
- 迭代学习，每一次迭代都是一个完整的循环，设计没有终点，永远可以持续改进;
- 组合运用思维模式
# 第3章 指定设计策略
- 软件系统充满了不确定性，但是也必须制定计划;
- 架构设计不是一蹴而就，而是持续不断的学习以及实验。
## 找到够用的设计
不是寻找最佳设计而是找到够用的设计，寻找够用设计的方法:
- 将解决方案看成实验;
- 降低设计风险;
- 努力简化问题;
- 快速迭代学习；
- 同时考虑问题与解决方案
## 决定前期做多少架构设计
开发，架构设计，返工是项目工期的3个主要部分，架构设计时间不能太长也不能太短，根据软件复杂度不同，有一个最佳的平衡点，架构设计与返工时间反相关，根据研究:
- 软件系统越大，前期做架构设计的收益就越大，一般37%时间做架构师合理的;
- 软件系统越小，前期做架构设计的收益就越小，一般不超过5%;
- 架构设计做的不够，后期要返工，
软件系统可以按照规模或者复杂度评估工作量，但是一般复杂度更准一些，还要考虑需求波动。
## 用风险做向导
风险可以提醒什么东西可能会造成障碍，按优先级直觉列出可能的问题，选择合适的思维模式降低风险。
风险用条件(当前状况)与后果(可能的问题)描述。降低风险的方式:
- 降低概率;
- 减少影响;
- 减小风险发生的时间窗口;
- 移除条件;
- 接受现状，什么也不做.
软件架构设计师一种降低风险的活动，风险帮助我们决定设计内容，思维模式帮助制定降低风险的策略，风向与思维模式:

|风险|思维模式|
|:---|:---|
|要解决的问题还不确定，对于利益相关方和其他系统参与者，还需要更深入的理解|理解|
|解决方案还不确定，需要充分了解可选的方案|探索|
|利益相关方不完全了解准备实施的方案|展示|
|在设计决策上举棋不定|评估|

架构师需要将技术风险降低到架构不在是系统中的最大风险源，也就是到达恰如其分的状态，此时可以从主动设计转为被动设计:
- 主动设计是主动设法降低架构风险;
- 被动设计是指监控系统运行表现，并采取纠正措施。
架构还可能重新成为风险源，要切换回主动设计模式。
## 制定设计计划
设计计划指出团队在架构设计上分配时间的总体策略，包含的内容:
- 结束设计的条件（前期设计如何开展）
- 必要的设计成果（文档/图等存储）
- 时间节点关键设计工作的时间节点，至少给出对架构设计有重大影响的事件的时间节点(需求审查、设计审查、设计评估)，还有与利益相关方会面的时间节点，在开发工作即将开始或者确定初期工作包含的范围要召集相关会议;
- 重大风险，风险驱动的设计方法;
- 概念架构设计，可以先从可行的解决方案中选择一个，解决方案可以帮助定义问题，只要能表达初步的设计想法就行。
# 第4章 换位思考
搞清楚到底要解决什么的问题。
## 找合适的人交谈
利益攸关方有很多，同样角色的攸关方的人，可能想法也不同，需要攸关方团队确定唯一的想法。
## 创建利益相关方关系图
呈现了与软件系统有关系或者受其影响的人，将关系与互动进行可视化的呈现，展示利益攸关方的动机，并可以确定需要沟通的关键人物
>客户体验架构，通用电气软件架构师，以客户为中心的设计流程，先搞清楚谁是客户，他们想做什么，将系统按照客户的任务进行划分。
第一步: 观察客户在正常情况下如何完成任务，向对方提问确定对客户至关重要的事项包括功能需求与质量属性需求；第二步: 围绕客户的需求设计系统并记录在原型里，原型应尽可能具有交互性，而不仅仅是流程图; 第三步: 尽早语客户一起评审原型，确保对方真正了解新系统的变化以及这些变化对他们的影响; 第四步: 根据客户评审会上的反馈修改调整架构设计。
## 了解业务目标
所有软件系统的开发都是为了满足业务目标，业务目标是利益攸关方希望通过软件系统实现的东西，谈论系统的质量属性、权衡取舍、技术债务都要以业务目标为基础。业务目标是架构的主要驱动因素，描述业务目标就是阐明利益相关方想从软件系统获得什么。
- 记录业务目标，业务目标是可衡量的，有成功的标准。业务目标的描述要包含3个部分
  - 主体，特定的人员或者角色;
  - 结果，可衡量的结果表达利益相关方的需求，会带来哪些变化;
  - 背景，背景信息有助于进一步理解利益相关方的需求;
- 帮助利益相关方描述业务目标，架构师可以用一些模板帮助利益相关方表达需求。
  
# 第5章 挖掘关键架构需求
关键架构需求(architecturally significant requirement, ASR)是显著影响架构中的结构选择的需求，架构师有责任确定对架构有重大影响的需求，ASR分为4类:
- 约束，给定或者选定的不可更改的设计决策;
- 质量属性，外部可见特性，表征系统在特定环境下的运行情况;
- 影响较大的功能需求，架构设计需要特别注意的特性和功能;
- 其他影响因素，时间、知识、经验、技术、办公室政治、你的技术特长等.
## 用约束限制设计选择
约束是外界限定的或者自己选择的不可更改的设计决策，约束可以简化问题，也会增加设计难度，设计决策可能变得越来越像约束，要区分。
## 定义质量属性
质量属性描述了软件系统的外部可见特性和我们对系统运行的期望，也定义了系统执行某些操作时的表现，也称为质量需求下面是常见的质量属性:
|设计属性|运行属性|感知属性|
|:---|:---|:---|
|可修改性|可用性|可管理性|
|可维护性|可靠性|可支持性|
|可复用性|性能|简单性|
|可测试性|可伸缩性|指导性|
|可构建性或者开发时间|安全性||

设计决策就是提升某些质量属性同时牺牲另一些质量属性。关键架构需求主要就是为了确定系统的质量属性，质量属性用于在整个设计过程中指导挑选技术、结构、模式评估设计决策的合理性。功能需求描述系统行为，非功能性需求描述功能需求之外的其他系统需求，有质量需求与约束。设计软件架构必须区分功能、质量属性、约束，因为它们对设计的要求是不同的。质量属性就是非功能性需求。
1. 用场景描述质量属性
   质量属性场景描述了系统如何在特定环境下运行，每个场景都包含刺激和响应。质量属性场景与功能需求的不同在于: 质量属性场景对响应做了明确的限定，并给出了度量方式。除了能正确响应，如何响应也很重要，质量属性场景的6个元素（图在书上）。
   - 刺激，需要系统以某种方式最初响应的事件；
   - 来源，刺激的来源，人或者系统;
   - 软件部件，系统的某个部分
   - 响应，外部可见的活动，刺激引发响应
   - 响应度量，定义响应成功的标准与条件
   - 环境背景，系统的操作环境
  合格的质量属性场景应该表达需求的意图，确保所有人都能理解。
2. 寻找具体可衡量的响应度量
   良好定义的响应度量是可测试的，
3. 确定质量属性场景

## 对功能需求分类
功能需求定义了软件系统的行为，在某些情况下会影响系统架构设计。影响架构的功能需求的确定方法:
1. 先画出概念架构草图，展示当前对架构的构想
2. 对功能需求大致分类，每类需求反应一个相同类型的架构问题
3. 对照概念架构草图，思考每个分类如何实现，如果对于已知的粗粒度需求，实现功能的方式并不明显，那么它就可能对架构有重大影响

功能需求分类的策略如下:
- 寻找可以使用相同架构元素实现的功能需求，例如，需要持续运行的功能归为一类，需要用户交互的功能可以归在另一类;
- 寻找看起来有难度的功能需求，他们对架构可能有重大影响
- 寻找重要的，高优先级的需求

架构设计应该反应所有影响较大的功能需求。
## 找出其他影响架构的因素
影响架构的其他因素包括: 当前的技术趋势、团队组织、影响较大的功能需求、质量属性、约束、业务目标、团队的能力，技术，知识、架构师的能力，技术，知识等。
团队的组织结构与合作形式会影响架构设计，康威定律描述了团队组织结构与架构之间的关系:
> 任何设计系统的组织产生的设计必然是该组织沟通结构的写照
## 挖掘关键架构需求
关键架构需求往往是隐藏的，需要挖掘。产品代办列表是挖掘关键架构需求的宝藏，功能需求都隐含或者暗示了某些质量属性。与利益相关方沟通，挖掘关键需求的方法:
- GQM会议将业务目标与质量属性度量数据化;
- 利益相关方访谈，搞清楚质量属性场景和约束;
- 假设清单，将隐藏需求明晰化公开化;
## 创建ASR工作薄
发现关键架构需求后，记录在工作簿中。为所有相关人员提供系统背景信息。ASR工作簿大纲:
- 目的与范围
- 阅读对象
- 业务背景
  - 利益相关方
  - 业务目标
- 关键架构需求
  - 技术约束
  - 业务约束
  - 质量属性需求
    - 重点场景
  - 有影响力的功能需求
    - 重点用户或用户角色
    - 用例或用户故事
- 附录A: 术语表
- 附录B: 质量属性分类

了解利益相关方及其目标是通过软件实现价值的第一步。需要做到积极倾听，试着理解。可以使用ASR工作簿向团队及其他人员介绍架构概念。
## 小结
不同的架构可以实现相同的功能，功能本身不能帮助我们决定如何设计架构，还需要知道关键架构需求，尤其是质量属性，这决定了对架构方案的取舍。解决方案源自我们对问题的理解，不需要等到完全清楚问题之后再考虑解决方案，探索解决方案会加深你对问题的理解，不断发现新的情况是正常的。
# 第6章 主动选择架构（choose an architecture）
架构设计就是在不确定的情况下做决策。就是取舍妥协，放弃一些东西避免更坏的情况发生，接受不好的条件以便在其他方面做的更出色，只要做出合适的取舍，就可以实现关键架构需求完成业务目标。
## 发散探索，聚合决策
做决策意味着需要多个备选方案，要获得备选方案，需要进行设计探索。设计探索是反复的发散与聚合的过程。确定问题后，需要发散思维，探索解决问题的各种方案。找到备选方案后，又需要聚合思维取得共识，排除不适合的方案。架构师重点关注质量属性、架构结构以及会对2者产生影响的设计决策。所有的架构都是设计，并非所有的设计都是架构。软件架构是关于如何组织软件的一系列重大设计决策的集合。旨在实现期望的质量属性和其他软件特性。架构师必须探索重大重大设计决策，主动选择软件的组织方式以实现既定的质量属性。下面是架构设计通常要探索的几个方面:
- 探索元素及其作用，确定架构的结构组成。探索方案就是探索功能各异的元素的组合形式;
- 探索关系及其接口，确定元素的交互方式。关系描述了架构中2个元素如何协同工作以完成任务。组件接口就是一种关系。通信机制和通信规则定义了接口。
- 探索问题领域，理解架构所处的环境。每类问题都有自己的术语和概念，描述了它存在的环境。领域中的概念，无论是对象还是事件，都必须在架构的相应之处加以说明。对问题领域理解的越透彻，对架构元素的划分及功能分配就越理想。
- 探索技术和框架，提升质量属性。探索各种中间件/库的优缺点更好的发挥作用。
- 探索构建和部署方法，确保架构可以交付。
- 探索以往的设计，获得启发指导决策。所有设计都是在已有设计基础上的重新设计和调整创新。大多数架构探索始于温故。审视已知的软件设计知识。设计知识可以总结成经验法则和模式。

2种部署方法，红黑部署/滚动升级。出现不一致，强制兼容、开关、容错处理等方式避免不一致。
## 接受约束
约束是无法更改的既定设计决策。约束：
- 技术约束
- 业务约束，可能不是很明显
- 早起的设计决策，重构可以变更。
## 提升质量属性
架构师通过选择结构来提升系统的质量属性。选择结构就是探索各种架构模式。借助质量属性探索架构模式。一个例子是构建数据驱动的web应用3种架构模式:
![3种架构设计模式](pic/3%E7%A7%8D%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png)
3种模式分别提升/抑制了不同的质量属性。
- 3层模式，每一层完成不同的任务，易于测试、部署、描述。可伸缩性与可用性差。
- 所有元素都讲消息发布到事件总线上。组件可以订阅感兴趣的消息。事件可能不按顺序传送，也不确保传送成功，具有较高的可更改性与灵活性。适合构建松耦合系统，但是消息的顺序也会造成加大的影响。
- 面向服务架构模式，服务都在中央注册表注册，以便调用者可以找到它们，组件查找并直接调用这些服务，服务响应并回复信息。可更改、灵活、可测试的特点，易于扩展，易于提升可用性。但是复杂。
  
选择架构模式关键要看质量属性，针对既定质量属性，分出各种模式的优劣。决策矩阵(decision matrix)是一个表格。用于总结/分析多个架构设计方案的利弊，它适合用来选择与架构有关的各种设计选项，包括架构模式、功能分配、技术方案等。
![决策矩阵](pic/%E5%86%B3%E7%AD%96%E7%9F%A9%E9%98%B5.png)
决策矩阵的第一列列出备选特性，矩阵每一行代表一个特性，每一列是你对相应设计选项的分析判断。
## 为架构元素分配功能
项目中的每个元素都有功能，选择架构时会为每个元素分配特定的功能。以便实现所有既定的功能需求。确保每个功能都有且仅有一个元素负责。至少负责一个功能。
## 设计，应变而生
通过选择决策时间点以及将设计决策移出架构，可以做到应变设计。避免走入死胡同或者走上歧路的办法是推迟决策。可以为研究，探索争取更多的时间。最后责任时刻-在避免失去重要备选方案的前提下，做出决策的最晚时间。做出设计决策的最佳时机:
- 不做决策是否阻碍了项目进展;
- 决策是否解决不能再耽搁的问题;
- 决策是否会创造更多的选项或机会;
- 推迟决策是否明显会带来更多风险;
- 我是否理解并接受设计决策带来的一切后果;
- 我有明确的理由说明为什么现在必须做这个决定吗?
- 如果决策失误，是否有时间弥补，我能承受这样的错误吗?
可以把容易变化的东西移出架构，在可能的情况下，应该把容易变化的设计决策留给后续设计人员来做。SOLID原则用于架构设计。
- single responsibility 单一功能;
- open/closed 开闭原则
- liskov substitution 里氏代换
- interface segregation 接口隔离
- dependency inversion 依赖反转
将设计决策移出架构的方法:
- 可插拔/可替换的架构;
- 外部配置;
- 自描述数据;
- 动态发现
它们都是在设计时/运行时更改系统的行为。
## 小结
接受约束、探索能实现既定质量属性的模式、找出影响较大的功能需求并选择合适的架构、在正确的时间做出决策、尽可能提高架构的可修改性。
# 架构模式
提炼解决常见问题的的方案，总结可复用的模式。所有软件系统都有自己的核心模式，设计决策都以此核心模式为基础，根据特定的需要做修改。使用模式相当于汲取前人的智慧。
## 什么是架构模式
架构社区构建可扩展、可维护、可靠、高可用、可测试的软件系统。大部分的软件设计问题都有已知的解决方案。所说的模式(标准的结构或者样式)就是指这些已知的解决方案。
维基百科的解释: 是存在于人们感知到的世界、人造设计或抽象思想中的规律。模式的元素以可预测的方式重复。架构模式是针对特定问题的可复用的解决方案。通过特定的结构组合提升某方面的质量属性。使用模式可以方便沟通，同时也有助于理解现有的框架/平台的架构设计思想。设计模式，用于提升面向对象程序的可复用性，可维护性。架构模式关注各种质量属性下的解决方案。比较宽泛。
## 分层模式
分层是最常用的架构模式。分层模式实现了层间低耦合与层内高内聚。提升了可维护性。如果想更改模块内的代码而不影响其他模块，就应该使用分层模式。

| **类别** | **模块**                                                             |
|--------|--------------------------------------------------------------------|
| 元素     | 层: 一组功能内聚的模块                                                       |
| 关系     | 允许使用，哪些层可以使用其他层的模块                                                 |
| 使用规则   | 所有模块必须划分到某一层里，上层可以使用下层，这种关系是单向的，允许使用关系可以进行限制让当前层只能使用处于其下方的层，禁止循环依赖 |
| 优势     | 提升可维护性、可移植性、可复用性、可测试性、设计阶段的可修改性。概念上比较容易实施，分层可以直观的反映在代码上            |
| 劣势     | 每一层都引入了额外的抽象，增加了复杂度，可能会影响性能，层数繁多与抽象泄漏可能会导致开发过程比较痛苦                 |

![分层模式](pic/分层模式.svg)
## 端口适配器模式
端口适配器模式隔离了核心业务逻辑，确保它可以在多种环境下使用。以及在隔离其他组件的情况下测试。在运行时，可以讲输入源的可插拔适配器注入核心业务逻辑中，以提供对事件或数据的访问。构建或运行时可以通过切换适配器生成各种系统配置。

| 类别   | 模块或者组件连接器                                                                                 |
|------|-------------------------------------------------------------------------------------------|
| 元素   | 层: 包含业务逻辑，不清楚使用的数据和事件来源，端口: 层与适配器之间的接口。借助端口层可以与具体的适配器分离，适配器: 与外部数据源、设备进行交互的代码使得层能够访问数据和事件 |
| 关系   | 暴露：指明层可用的端口，实现: 指明约束适配器的端口，注入: 指明层可用的适配器                                                  |
| 使用规则 | 层通常会暴露端口，没有端口的层也叫做内层，                                                                     |
| 优势   |                                                                                           |
| 劣势   |                                                                                           |

## 管道过滤器模式
管道过滤器模式里面的组件称为过滤器，负责单一的数据转换与数据操作。数据快速从一个过滤器流转到下一个过滤器，数据操作是并发进行的，松耦合的过滤器可以复用与组合创建新管道。多用在数据分析/数据转换领域。Unix终端命令连接在一起，就是管道过滤器模式。

| **类别** | **组件连接器**                                                                                                                                     |
|--------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| 元素     | 过滤器: 读取、转换、记录数据的组件，过滤器可以在读取数据的第一时间开始处理，必须定义预期输入与预期结果。管道:  连接器，用于将数据从一个过滤器传输到下一个过滤器，管道具有单一输入与输出，不会改变传输的数据。该模式的一些变种还包括source/sink，专门产生/接收数据的过滤器 |
| 关系     | 接驳：通过管道连接一个过滤器的输出与另一个过滤器的输入                                                                                                                   |
| 使用规则   | 管道只能连接与其输入输出兼容的过滤器，过滤器完全相互独立                                                                                                                  |
| 优势     | 提升性能，可复用性，可修改性                                                                                                                                |
| 劣势     | 管道过滤器系统不是交互性的，不包含用户界面， 不会明显提升可靠性，简单实现可能会影响性能                                                                                                  |

![管道过滤器模式](pic/%E7%AE%A1%E9%81%93%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F.svg)

批处理模式和管道过滤器模式很像，批处理模式是各个阶段逐个逐次操作，管道过滤器是流水线并发操作。
## 面向服务架构模式
SOA模式，用独立的组件提供特定功能的服务，各种服务在运行时整合在一起，决定系统的行为，要求服务的使用者必须在不清楚服务实现细节的情况下寻找和调用服务。有很多种实现方式，传统的SOA非常倚重消息总线和SOAP通信，现代SOA则使用细粒度的微服务。用轻量级的HTTP协议进行连接。复杂的组织通常使用SOA来设计大型系统，不同的部门管理不同的系统部分。SOA允许各个部门在其专业领域内独立工作(隐藏重要业务信息)，这些子系统又能供外部访问。

| **类别** | **组件连接器**                                                                                          |
|--------|----------------------------------------------------------------------------------------------------|
| 元素     | 服务: 可独立部署的单元，通过定义好的接口提供服务功能;
服务注册表: 列出所有可用的服务，以便服务可以查找其他可用服务
消息系统: 取决于具体的系统设计，如SOAP、REST、gRPC、异步消息 |
| 关系     | 根据SOA系统的约束而变化，如果使用netflix的智能端点与哑管道方法，则关系调用，如果使用异步消息，则关系是发布/调用
                                     |
| 使用规则   | 服务不必知道所有的其他服务的实现细节，服务必须通过外部组件发现其他服务，要么是服务注册表，要么是异步消息传递的消息总线                                        |
| 优势     | 提升互用性、可复用性、可伸缩性。模式成熟，有很多子模式                                                                        |
| 劣势     | SOA系统是分布式系统，带有分布式计算的所有复杂性，组成部分多，集成复杂                                                               |


![SOA](pic/面向服务的架构模式.svg)
架构失配: 对组件的预期用法与实际使用情况有冲突。如果选择的架构模式与高优先级的质量属性有冲突，则是架构失配。如果选择的实现技术与架构设计不一致，也属于架构失配。
## 发布订阅模式
发布订阅模式中，生产者与消费者在彼此不知情的情况下独立存在。大量的消费者订阅各种生产者发布的事件，生产者与消费者通过事件总线间接通信，事件总线负责将发布的事件与感兴趣的订阅者连接起来，事件总线技术的选择极大地影响系统属性。如果有多个独立组件要访问相同的信息，可以使用发布订阅模式。

| **类别** | **组件连接器**                                                                            |
|--------|--------------------------------------------------------------------------------------|
| 元素     | 发布者: 发布事件的组件，发布的事件应在设计文档中描述
订阅者: 订阅事件的组件
事件总线: 负责登记组件订阅和传递发布的事件，事件总线提升的属性由具体技术及其配置决定 |
| 关系     | 发布: 组件将事件发布到事件总线
订阅: 组件登记订阅事件                                                        |
| 使用规则   | 所有通信都通过事件总线进行。因此，所有组件必须连接到总线。某个组件可能既是发布者又是订阅者                                        |
| 优势     | 提升可扩展性、可复用性、可测试性。根据事件总线的选择及其配置方式，还可以提升可用性、可靠性、可伸缩性                                   |
| 劣势     | 性能很难判断                                                                               |

![发布订阅系统](pic/发布订阅模式.svg)
大部分发布订阅系统都有一个事件规范文档，定义了组件可以订阅事件，描述事件格式与发布事件的组件。
## 共享数据模式
通过共用的数据库访问数据，没有组件单独对数据或者数据存储负责。特别适合有大量数据，多组件的系统。

| **类别** | **模块或者组件连接器**                                                                                                   |
|--------|-----------------------------------------------------------------------------------------------------------------|
| 元素     | 数据库: 保存访问器共享的数据，数据存储的选择及其约束决定了能实现的质量属性;
数据访问器组件: 以某种方式使用数据的组件                                                   |
| 关系     | 读取: 数据访问器组件可以从共享数据库中读取数据，某些读取关系可能需要特定协议或对可读取的数据量、类型进行限制;
写入: 数据访问器组件将数据写入共享数据库，写入关系可以采用事务形式，进行限流和保护，或者用其他方式进行约束 |
| 使用规则   | 只有数据访问器可以与共享的数据库进行交互                                                                                            |
| 优势     | 通过数据一致性、安全和隐私提升可靠性，如果数据库充分优化，数据访问器划分良好，可以提升可伸缩性和可用性                                                             |
| 劣势     | 可能导致单点故障，从而影响可用性和性能，如果数据库发生变更，可维护性也会受影响，因为所有数据访问器都需要变更                                                          |

![共享数据模式](pic/共享数据模式.svg)
## 多层模式
系统运行时的结构被组织称逻辑组，逻辑组可以被分配到特定的物理组件。如果系统的组件将在不同的平台或者硬件上运行，可以考虑使用多层模式

## 能力中心模式
深层模型包含了领域的核心概念与抽象，能够以简单灵活的方式表达出基本的用户活动、问题以及解决方案。深层建模的第一步就是要设法在模型中表达出领域的基本概念，在不断的消化知识与重构中，精化模型。这个过程是从我们识别出某个重要概念并在模型与设计中把它显式的表达出来开始的。开发人员发现一个新的概念，就要重构代码或新增对象把概念显式的表现出来。找到隐含概念才能获得突破。
# 9.1 概念挖掘
开发人员需要敏锐的捕捉到隐含概念，可以主动寻找，几个方式
- 倾听团队语言，找出设计中没有的领域专家说的术语名词概念等，
- 检查设计的不足，操作复杂且难于理解的地方，新的需求会使功能更复杂的地方，对象的职责实现很笨拙的地方；需要自己探索想法，并跟领域专家验证；
- 检查设计与专家矛盾的地方，不同的领域专家的看法概念可能不同，也有可能领域概念前后不一致，将矛盾统一起来可以获得对模型的更深层次的理解，
- 研究领域相关文献，看书与咨询领域专家不冲突，或者是参考此领域中有过开发经验的人员编写的资料。
每次改变都会把开发人员更深刻的理解添加到模型中，每次重构都会使设计变的灵活，并且为可能需要修改的地方做好准备，只有不断尝试才能知道什么有效，什么无效，企图避免设计上的失误将会导致开发出来的产品质量低劣，因为没有更多的经验可用来借鉴，同时也会比进行一系列快速实验更加费时。
# 9.2 如何为那些不太明显的概念建模
约束是模型概念中非常重要的类别，通常是隐含的，显式的表现出来可以极大的提高设计质量。比如一个简单的固定规则
```java
class Bucket {
    private float capacity;
    private float contents;
    public void pourIn(float addedVolume){
        if(contents+addedVolume>capacity){
            contents=capacity;
        }else {
            contents=contents+addedVolume;
        }
    }
}
```
在更复杂的类中，约束将丢失，将它提取到一个单独的方法中，并用清晰直观的名称来表达它的含义。
```java
class Bucket {
    private float capacity;
    private float contents;
    public void pourIn(float addedVolume){
        float volumePlacedIn=contents+addedVolume;
        contents=constrainedToCapacity(volumePlacedIn);
    }
    public void constrainedToCapacity(float volumePlacedIn){
        if(volumePlacedIn>capacity)return capacity;
        return volumePlacedIn
    }
}
```
后面的方式也为约束扩展提供了空间，有的情况下，提取为方法是无法表达约束的，比如约束需要用到其他的信息，这些信息不是当前对象的主要的职责，这个时候约束规则不适合放到当前的对象中。下面情况下需要单独提取为对象或者类
- 约束需要外来的数据;
- 规则在多个对象中出现，造成代码重复，或不属于同一个族的对象产生了继承关系;
- 规则在设计与需求中比较重要。
一个货运中的约束的例子
![约束的例子](9/constraint.png)

领域中的过程必须在模型中表示出来，经常被领域专家提起的过程需要显示的表达出来。

模式：Specification
业务规则通常不适合作为Entity或Value Object的职责，而且规则的变化与组合也会掩盖领域对象的基本含义，当时将规则移出领域层的结果会更糟糕，这样一来，领域代码就不再表达模型了。逻辑编程提供了一种概念，即谓词，这种可分离，可组合的规则对象；要把这种概念用对象完全实现是很麻烦的，这种概念过于通用，在表达设计意图方面，它的针对性不如专门的设计那么好。我们可以使用谓词概念来创建可计算出布尔值的特殊对象，负责的规则方法可以单独提取为一个对象，它们都是一些小的真值测试，可以提取到单独的Value Object中，新对象可以用来计算另一个对象，看看谓词对那个对象的计算是否为真。
![规格](9/specifiction.png)

这个新对象就是一个规格。Specifiction可以测试任何对象以检验它们是否满足指定的标准。Specifiction将规则保留在领域层，
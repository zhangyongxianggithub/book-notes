复杂的软件缺少良好的设计时，重构或者元素的组合会变得困难，因为不了解代码的逻辑，可能会重复书写一些逻辑一样的代码。，又不敢破坏历史的代码，可能会更乱或者破坏了依赖，这样限制了重构与迭代的精华，限制了程序提供功能的上限。
为了让项目能够随着开发工作的进行加速前进，不会由于自己的老化停滞不前，设计时必须乐于使用且乐于修改，这就是柔性设计(supple design)。
坚持模型驱动的设计方法，当复杂性阻碍了项目的前进时，就需要仔细修改最关键、最复杂的地方，使之变成一个柔性设计。才能突破复杂性带给我们的限制，而不会陷入遗留代码维护的麻烦中。柔性设计没有公式，一些模式运用得当，可以获得柔性设计。
# 模式： Intention Revealing Interfaces(意图展示接口)
领域驱动的设计中，希望突出有意义的领域逻辑（变成名字啥的，不要隐藏在多行的代码中）这样需要一行一行读代码.
![可以获得柔性设计的模式](10/supple-pattern.png)
客户开发人员想要有效的使用对象，必须知道对象的一些信息，如果接口没有表示这些信息，那么就需要研究对象的内部实现，理解细节，这就失去了封装的意义，如果需要思考使用组件的大量细节，也没有时间解决上层问题的复杂性。如果使用组件的开发者，不得不通过其实现来推断用途，推断出来的用途不一定就是接口定义的用途，如果不符合定义，代码虽然可以暂时工作，但是设计的概念基础被误用了，开发人员的意图也相反了。当把概念显示建模为类或者方法时，必须起一个能够反映概念的名字。
使用Intention Revealing Selector选择方法的名称，使名称表达出目的，名字的命名方法如下：要描述效果与目的，复杂的机制封装在抽象背后，接口只表明意图不表明方式。
# 模式：side effect free function可以让方法的执行结果变得易于预测
操作可以分为2大类：
- 命令
- 查询
副作用=意外的结果，任何对系统状态产生的影响都叫副作用。
多个规则的相互作用或计算的组合产生的结果是很难预测的，为了预测操作的结果，必须理解底层的内部实现与其他的关联调用，那么接口抽象就失去意义，如果没有可以安全的预见结果的接口抽象，那么接口实现就必须简单，组合的复杂性就要被降低，系统的功能与行为就会减少。返回结果而不产生副作用的操作称为函数，因为没有副作用可以降低风险。
减少命令的副作用的2个方法
- 把命令与查询放在不同的操作中，确保导致状态改变的方法不返回领域数据，保持命令简单，在不引起副作用的方法中执行查询与计算
- 一些模型与设计创建返回Value Object表示计算结果，不能被修改，也不影响Entity，Entity的生命周期受到严格管理，Value Object随时可以创建丢弃.
如果一个操作把逻辑或计算与状态改变混合在一起，应该把这个操作重构为2个独立的操作。把副作用隔离到简单的命令方法的做法仅适用于Entity，Value Object负责复杂的计算逻辑.
尽可能把程序的逻辑放到函数(无状态的方法)中，函数只返回结果，不产生副作用；把命令隔离到不返回领域信息的简单的操作中，当发现一个非常适合承担复杂逻辑职责的概念时，把复杂的逻辑移到Value Object中，可以进一步控制副作用。因为是Value Object，所以可以随便使用。可以看下mixIn()方法的副作用
![副作用](10/side-effect.png)
修改于查询分离。这个问题中，颜色是很重要的概念，把它变成一个显示的对象。
![油漆的颜色](10/pigment-color.png)
PigmentColor是一个ValueObject，独立出对象后，相关的操作也要独立出来，那么与volume的改变就毫无关系了，只与Paint有关系，它是具有生命周期的实体。调漆的结果就是产生一个新的PigmentColor对象.
![调漆模型](10/pigment-color2.png)
产生的类如下
```java
public class PigmentColor{
    public PigmentColor mixedWith(PigmentColor other,double ratio){
        // many lines of complicated color-mixing logic
        // ending with the creation of a new PigmentColor object
        // with appropriate new red,blue,and yellow values
    }
}
public class Paint{
    public void mixIn(Paint other){
        volumme=volume+other.getVolume();
        double ratio=other.getVolume()/volume;
        pigmentColor=pigmentColor.mixedWith(other.pigmentColor(), ratio);
    }
}
```
![新的color对象](10/new-pigmentcolor.png)
## 模式：Assertion




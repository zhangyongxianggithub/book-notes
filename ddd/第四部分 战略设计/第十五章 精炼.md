专注于核心问题的一种的方法是使用Layered Architecture，这种架构可以把领域概念从技术逻辑中分离出来；精炼是把一堆混杂在一起的组件分开的过程，以便通过某种形式从中提取出最重要的内容，使得得到的结果更有价值也更有用，模型就是知识的精炼，通过每次重构所得到的更深层的理解，得以把关键的领域知识与优先级提取出来。精炼的主要动机是把最有价值的部分那部分提取出来，正是这个部分使我们的软件区别与其他软件并让整个软件的构建物有所值，这个部分就是CORE DOMAIN。领域模型的战略精炼包含一下部分:
- 帮助团队的所有成员掌握系统的总体设计以及各部分如何协调工作;
- 找到一个具有适度规模的核心模型，并把它添加到通用语言中，促进沟通;
- 指导重构;
- 专注于模型中最有价值的那部分;
- 指导外包、现成组件的使用以及任务委派;
![战略精炼导航图](15/purify-navigation.png)
# 15.1 模式：CORE DMAIN
大型系统有很多组成部分，这导致最核心的业务模型往往不够突出甚至被掩盖忽略，难以理解的系统修改起来会很难，而结果也很难预料；开发人员可能不熟悉当前的模块或者开发人员只了解一个模块的内容而不了解全局，这种壁垒导致系统很难平滑的集成，也不好灵活分配工作，功能可能会实现多次，使系统变得更加复杂。
大型系统中不可能对所有设计部分呢精化，必须分出优先级，为了使领域模型称为有价值的资产，必须整齐的梳理出模型的真正的核心，并根据这个核心创建应用程序的功能。
高水平开发人员往往只关注于技术基础设置或是一些通用的技术问题上。而真正体现应用程序价值的领域核心确是有水平稍差的开发人员完成的，如果模型很差，不论技术基础设施建设的有多好，应用程序不能为用户提供更好的功能。
在制定项目规划的时候，必须把资源分配给模型与设计中最关键的部分，在规划与开发期间，每个人都必须识别与理解这些关键部分。这些部分就是CORE DOMAIN。对模型进行精炼，找到CORE DOMAIN并把它与起辅助作用的模块与代码分开，最有价值和最专业的概念要轮廓分明，尽量压缩CORE DOMAIN。让最有才能的人来开发CORE DOMAIN。在CORE DOMAIN中努力开发能够确保实现系统蓝图的深层模型与柔性设计，仔细判断任何其他部分的投入，看它是否能够支持这个提炼出来的CORE。当必须在2个看起来都很有用的重构之间进行抉择时，应该首选对CORE DOMAIN影响最大的那个重构。
- 选择核心，需要关注能够表示业务领域并解决业务问题的模型部分，CORE DOMAIN的选择取决于看问题的角度；
- 工作中的分配，需要存在一个最有能力的开发人员来开发CORE DOMAIN。聘请短期的专业人员来开发CORE DOMAIN是不行的，会造成知识的流失，购买CORE DOMAIN也是行不通的，自主开发的软件的最大价值就是对CORE DOMAIN的完全控制，使用框架可以节省开发更通用部分的时间，因为框架做了，可以专注于CORE，但是框架必然有某些限制；
    - 如果限制太多，应该把框架从CORE DOMMAIN中剥离;
    - '
## 15.2 精炼的逐步提升
各种精炼技术在使用顺序上没有要求，对设计的改动是不同的。
## 15.3 模式：Generic Subdomain
模型中有些部分除了增加复杂性外没有捕捉或者传递专门的知识，任何外来的因素都会使CORE DOMAIN难以分辨与理解，模型中充斥着大量众所周知的一般原则，或者是专门的细节，这些细节并不是我们主要的关注点，只是起到支持作用，无论它们是多么通用的元素，对实现系统功能与充分表达模型都是必要的。识别出那些与项目意图无关的内聚子领域，把这些子领域的通用模型提取出来，并放到单独的MODULE中，任何专有的东西都不应该放在这些模块中。把它们分离出来以后，在继续开发的过程中，它们的优先级应低于CORE DOMAIN的优先级，并可不要分派核心开发人员来完成这些任务（因为他们很少能够从这些任务中获得领域知识）。还可以考虑为这些GENERIC SUBDOMAIN使用现成的解决方案或者公开发布的模型。开发这样的软件包时，有以下几种选择:
1. 现成的解决方案，使用开源代码或者购买现成的方案
优点:
- 减少代码开发;
- 维护负担转移到外部;
- 比自己开发的代码更可靠，更完备;
缺点:
- 使用之前需要花时间评估理解;
- 无法保证正确性与稳定性;
- 包含的内容远远多于自己需要;
- 集成不方便;
- 可能会引入对平台、编译器版本的依赖等。
Generic Subdomain通常打包为框架的形式，实现了非常抽象的模型，可以与应用程序集成满足特殊需求，越通用，则模型的精炼程度越高，用处就越大;
2. 公开发布的设计或模型
优点: 
- 比自己开发的模型更成熟，反映了很多人的深层知识;
- 提供了随时可用的高质量文档
缺点:
- 可能不符合需要或者超出需要的范围
领域中已经存在好的模型，那么就使用它，因为它是被广泛接受的，不需要专门的培训；或者如果只是已存在模型的一部分符合我们的需要也可以直接使用，不要自己实现，因为比较成熟，也有文档。
3. 把实现外包出去
优点:
- 核心团队处理CORE DOMAIN，那是最需要经验与知识的部分;
- 可以维持较小的团队规模，保证CORE DOMAIN的知识不会发散;
- 面向接口的设计有助于保持子领域的通用性，并定义为规格;
缺点:
- 多了一些沟通，需要核心开发人员与外包商定接口等一些信息;
- 交付时，要花时间来理解外包写的代码;
- 代码质量无法掌握;
自动测试或者单元测试有助于确保交付的代码的质量并且再集成方便。
4. 内部实现
优点:
- 易于集成;
- 只开发自己需要的，不做多余的工作;
- 可以临时把工作分出去;
缺点:
- 需要花时间维护与培训使用;
- 开发这些需要时间或者其他成本

CORE模型会变得越来越小，通用模型会作为框架或者公开发布的模型或者分析模式而变得越来越多，大部分模型需要自己开发，但是与CORE DOMAIN分区开很有价值.
### 通用不等于可重用
子领域要保持通用性，不要关注可重用性，因为原则就是把精力放在CORE上，只需要把业务所需要的那部分建模出来并实现，只投入必要的精力就可以了。可能会重用，但是没必要关注。通用子领域的设计必须严格限定在通用概念的范围之内，不要引入行业专用的模型元素，这会限制通用子领域的扩展而且行业专用模型比通用子领域模型更有价值。
### 项目风险管理
敏捷过程建立一个初始的模型+外围通用子领域构成的整体系统，这可能是为了验证技术架构，这种方式不利于风险管理，很容易低估领域建模的风险，未预料到存在的复杂性、存在理解偏差或者关键技术欠缺等。除非团队拥有精湛的技术或者对领域非常熟悉，否则第一个雏形系统应该以CORE DOMAIN的某个部分作为基础，不管它有多么简单。
## 15.4 模式: Domain Vision Statement
在项目的开始阶段，模型并不存在，模型可能包含了多个Bounded Context，而开始开发阶段对系统的价值是清楚的，Domain Vision Statement一个重点关注领域模型的文档，是对CORE DOMAIN的简短的描述以及它将会创在的价值，不需要写那些领域模型与其他领域模型一样或者相同的方面，只写独特的方面，展示出领域模型是如何均衡各方利益的，随着新的理解修改它，团队中的所有人员都可以参与修改。它作为一个指南，管理人员根据它来分配资源或者培训，开发人员用于精炼模型与代码.
## 15.5 模式: Highlighted Core
每个人对CORE DOMAIN包含哪些内容有不同的理解，为了不下影响设计避免过多的投入精力在筛选CORE DOMAIN，CORE DOMAIN要能非常容易的识别出来。对代码所做的重大结构性改动是识别CORE DOMAIN的理想方式，通过修改模型的组织结构，用MODULE表达核型领域，改动太大，短时间不能完成。轻量级的解决方案是挑选几个图或者文档作为思考的切入点。
### 精炼文档
一个简单的文档用来描述解释CORE DOMAIN。可能是核心概念对象的描述或者关系的描述，可能是图或者文字或者UML图或者是什么都随便，它不是设计文档，是一个高度抽象的总体视图。
### 标明CORE
把模型的主要存储库中的CORE DOMAIN标记出来，可以通过记号笔或者代码中的注释标记出来。只要能分辨出什么在核心领域内，什么在核心领域外就可以了。
### 把精炼文档作为过程工具
如果模型需要修改，那么精炼文档也要改，这是核心概念的改变，需要整个团队商量并同步理解。文档外的模型修改不需要全员了解，没有必要，后续涉及到再了解就可以。
## 15.6 Cohesive Mechanism
接口封装机制把做什么与如何做分开，有个不好的地方是方法的实现，内部逻辑越来越来，常常把概念性的做什么掩盖。为解决问题提供的算法的大量方法（命令式内部方法）掩盖了用于表达问题（与领域概念相关的表达问题概念）的方法。这时需要重构得到深层理解，需要找到一个能够使计算机制变的简单的模型，有的计算机制本身是非常内聚的，把内聚的部分提炼出来，剩下的部分就容易理解。把概念上的Cohesive Mechanism分离到一个单独的轻量级框架中，特别注意公式或那些有完备文档的算法，用一个Intention Revealing Interface来暴露这个框架的功能，领域中的其他元素就可以只专注于如何表达问题了，把解决方案的复杂细节转移给框架。这些被分离出来的机制承担起支持的任务，留下更小的、表达更清楚的CORE DOMAIN，这个核心以更加声明式的方式通过接口来使用这些机制。
轻量级的框架（通用子领域）可以使用已经存在的库或者自己实现，肯定是没问题的，因为前人肯定已经研究过了，可以放心的设计解决方案。CORE DOMAIN与GENERIC SUBDOMAIN描述事实、规则或者问题，COHESIVE MECHANISM用来满足规则或者用来完成模型指定的计算。
领域与各种计算逻辑混杂的后果:
- 模型会与用于解决问题的特殊方法耦合在一起，限制将来的选择与功能的扩展性;
- 模型将会变得复杂与混乱，分开后，可以使用声明式的的风格描述模型;
Cohesive Mechanism的一种使用场景式Specification，用一个框架来构造Specification对象，为这些对象需要的基本的比较与组合提供支持，CORE与GERNERIC DOMAIN可以声明规格，底层操纵留给框架完成。
GENERIC SUBDOMAIN与Cohesive Mechanism都是为了CORE DOMAIN减负，2者的责任不同，GENERIC SUBDOMAIN是以描述性的模型作为基础，与CORE一样用于描述领域的某个方面，只是是不重要的方面，Cohesive Mechanism不表示领域，只是为了解决描述性模型所提出来的一些复杂的计算问题。模型提出问题，Cohesive Mechanism解决问题，除非一开始就识别出一种正式的公开发布的算法，否则区别不是很清楚，后续的重构中，如果发现之前未识别的模型概念会使得这种机制变得简单，可以把这种算法精炼成一种更纯粹的机制或者转换为一个Generic SubDomain。
Cohesive Mechanism可能也是CORE DOMAIN的一部分，比如CORE算法的实现（他们是业务专用算法的实现，当然是核心业务的一部分）。不断的重构或者回到之前的设计也是很常见的，但是可能事实更加清楚，得到了更深层次的模型。
## 15.7 通过精炼得到声明式风格
精炼的价值在于看到自己正在做什么？不让无关细节分散注意力，通过不断消减得到核心，如果领域中那些起到支持作用的部分了一种简练的语言可以用与表示CORE的概念与规则又能把计算或者实施这些概念与规则的方式封装起来，那么CORE DOMAIN的重要部分就可以采用声明式设计，Cohesive机制通过Intention revealing interface来提供访问，并且具有概念上一致的ASSERTION与SIDE EFFECT FREE FUNCTION。利用内聚机制与柔性设计，CORE DOMAIN可以使用声明也就是接口，不用直接依赖实现，得到CORE DOMAIN的深层模型，深层模型与柔性设计往往一起产生，柔性设计变得成熟的时候，就可以提供一组易于理解的元素，我们可以明确的把它们组合到一起来完成复杂的任务或表达复杂的信息，就像单词组成句子一样，客户代码就可以采用声明式风格，更为精炼。把Generic Subdomain提取出来可以减少混乱，Cohesive Mechanism可以把复杂的操作封装起来，可以得到更专注的模型。
## 15.8 模式: Segregated Core
模型中的元素可能有一部分属于CORE DOMAIN，而另一部分起支持作用，核心元素可能与一般元素紧密耦合在一起，CORE的概念的内聚性可能不是很强，看上去也不明显，这种混乱性与耦合关系抑制了CORE，设计人员如果无法清晰地看到最重要的关系，就会开发出脆弱的设计。在把不重要的细节分离到Generic Domain中后，Core中可能还存在一些支持性的元素，为了得到内聚的CORE，精炼的CORE，此时需要对模型重构，把核心概念从支持性元素中分离出来，把所有通用元素或者支持性元素提取到其他对象中，并把这些对象放到其他的包中。得到Segregated Core的步骤如下:
- 识别出一个Core子领域(可能是从精炼文档中得到的);
- 把相关的类移到新的MODULE中，并根据与这些类有关的概念为模块命名;
  对代码进行重构，把那些不直接表示概念的数据与功能分离出来，把分离出来的元素放到其他包的类中，尽量把它们与概念上相关的任务放在一起，但不要为了追求完美浪费时间，把注意力放到提炼Core子领域上，并且使Core子领域对其他包的引用变得更明显且易于理解;
- 对新的Segregated Core Module进行重构，使其中的关系与交互变得更简单，表达的更清楚，最大限度的减少它与其他MODULE的关系（持续进行的重构目标）;
- 对另一个CORE子领域重复这个过程，直到完成Segregated Core的工作.
1. 创建Segregated Core的代价
把Core分离出来会使得CORE与非CORE类的关系更晦涩，但是CORE DOMAIN更清晰了；好处大于代价，Segregated Core可以提高CORE DOMAIN的内聚性，当系统有一个很大的Bounded Context时，模型的关键部分被大量的支持性功能掩盖了，就需要创建Segregated Core。
2. 不断发展演变的团队决策
CORE DOMAIN是不断演变的，随着segregate的进行，对CORE的理解也加深，对什么是核心什么是支持性元素产生新的理解，再将理解反馈到设计中，得到晚上的CORE DOMAIN与Segregated Core module的定义。新的理解必须持续不断的在整个团队中共享，整个团队做出敏捷决策来执行，整个团队共享同一个CORE视图。


模型最基本的要求是它应该保持内部一致，术语总具有相同的意义，不包含相互矛盾的规则，大型系统中无法保持这种统一，完全统一不可行，因为大型系统必须分模块开发。要保持模型关键部分的高度统一。
无法维护一个涵盖整个企业的统一模型，就要确定什么统一，什么不统一。统一的部分保持一致，不统一的部分不会混乱或者破坏模型。需要一种方式来标记不同模型之间的边界与关系，bounded context定义了每个模型的应用范围，context map定义了上下文与关系的总图，下图是模型完整性模式的导航图
![模型完整性导航图](14/model-navigator.png)
# 14.1 模式：bounded context
模型如果在不同的上下文中，就没有关联，是最简单的情况。但是想要复用模型的一部分工作时，会遇到问题比如，复用的边界在哪里？任何大型项目都会存在多个模型，而当基于不同模型的代码被组合到一起后，软件就会出现BUG、变得不可靠与难以理解，团队成员之间的沟通变得混乱，人们往往弄不清楚一个模型应该在哪个上下文中使用。一个模型只在一个上下文中使用，上下文可以是任何东西，比如代码、或者某个团队的工作，或者一次头脑风暴得到的模型的上下文就是头脑风暴讨论，模型只有在上下文中才有意义，上下文是模型的前提条件。明确的定义模型所应用的上下文也就是设置模型的边界，在这些边界中严格保持模型的一致性，而不要受到边界之外的问题的干扰与混淆。bounded context明确限定了模型的应用范围，以便让团队对什么应该保持一致以及上下文之间如何关联有一个明确和共同的理解，在context中，要保证模型在逻辑上统一，而不用考虑它是不是适用于边界之外的情况，在其他Context中，会使用其他模型。通过划定明确的边界，可以使模型保持纯粹，因而在它所适用的context中更有效，
# 14.2 Continuous Integration
当很多人在同一个Bounded Context中工作时，模型很容易发生分裂，团队越大，问题就越大，如果将系统分解为更小的Context，最终又难以保持集成度和一致性。有时开发人员没有完全理解其他人所创建的对象或者交互的意图，就对它进行了修改，使其失去了原来的作用，有时他们没有意识到他们正在开发的概念已经在模型的另一个部分中实现了，而导致了概念与行为重复，有时他们意识到了已经有了实现，却担心破坏现有功能而不敢去改动它，于是重复开发这些概念与功能。
Continuous Integration是指把一个上下文中的所有工作足够频繁地合并到一起，并使他们保持一致，以便当模型发生分裂时，可以迅速发现并纠正问题，有2个级别:
- 模型概念的集成;
- 实现的集成;
建立一个把所有代码与其他实现工件频繁的合并到一起的过程，并通过自动化测试来快速查明模型的分裂问题，严格坚持使用Ubiquitous Language，以便在不同人的头脑中演变出不同的概念时，使所有人对模型都能达成一致。
# 14.3 模式：Context Map
其他团队中的人员并不是十分清楚Context的边界，他们会不知不觉地做出一些更改，从而使边界变得迷糊，或者使互联变得复杂，当不同的上下文必须互相连接时，它们可能会相互重叠。限界上下文之间的代码重用是很危险的，应该避免，功能与数据的集成必须要通过转换去实现，通过定义不同上下文之间的关系，并在项目中创建一个所有模型上下文的全局视图，可以减少混乱。
识别在项目中起作用的每个模型，并定义其限界上下文，这包括非面向对象子系统的隐含模型，为每个限界上下文命名，把名称添加到Ubiquitous Language中，描述模型之间的连接点，明确所有通信需要的转换，并突出任何共享的内容。根据设计问题与项目组织问题的不同，限界上下文之间的关系有很多种形式，明确的Contextmap的画出是逐渐进行的，先找到一个比较接近的关系模式，找到那些特别明显违反模式的问题，修复，再观察，再修复。最终明确.
限界上下文应该有名称，以便可以讨论他们，这些名称应该被添加到团队的统一语言中，每个人都应该知道边界在哪里，应该能够分辨出任何代码段的Context，或任何情况的Context，比如通过Module的方式隔离Context，或者图、或者文本。
# 14.4 限界上下文之间的关系
模型之间的关系可以为组织开发工作设定目标并且可以为描述现有组织提供术语。
# 14.5 模式：Shared Kernel(共享内核)
![共享内核](14/shared-kernel.png)
当开发团队开发一些紧密相关的应用程序时，如果团队之间不进行协调，即使短时间内能够快速取得进展，但他们开发出的产品可能无法结合到一起，就是不方便集成，最后可能不得不耗费大量精力在转换层上，并且频繁的进行改动，不如一开始就使用Continuous Integration那么省心省力，同时也造成重复工作。从领域模型中选出2个团队都同意共享的一个子集，当然，除了这个模型子集以外，还包括与该模型部分相关的代码子集，或数据库设计的子集，这部分明确共享的内容具有特殊地位，一个团队在没有与另一个团队商量的情况下不应擅自更改它。
# 14.6 模式: Customer/Supplier Development Team
遇到服务依赖的问题，下游服务依赖上游服务，并且是不同的Context开发的，属于独立进行，如果下游团队对变更具有否决权，或请求变更的程序太复杂，那么上游团队的开发自由度就会受到限制，由于担心破坏下游系统，上游团队甚至会受到抑制，同时，由于上游团队掌握优先权，下游团队有时也会无能为力。最主要的就是上游更改时要下游的人员参与。在2个团队之间建立一种明确的客户/供应商关系，在计划会议中，下游团队相当于上游团队的客户，根据下游团队的需求来协商需要执行的任务并为这些任务做预算，以便每个人都知道双方的约定与进度，2个团队共同开发自动化验收测试，用来验证预期的接口，把这些测试添加到上有团队的测试套件中，以便作为持续集成的一部分来运行，这些测试使得上游团队在做出修改时，不必担心对下游团队产生副作用。这种模式有2个关键要素:
- 必须是客户供应商关系，就是客户提出要求，供应商要满足要求，如果多个客户，那么就平衡要求;
- 必须有自动测试套件，变更时不会相互影响。
# 14.7 模式: Conformist
当不能建立供应商/客户关系时，下游团队无能为力，只能靠自己，一种方案是放弃上游自力更生，但是如果上游价值较大，不允许放弃，如果上游很难用，需要开发转换层，转换成自己的模型，如果上游的模型与当前你的模型比较匹配，那么不要自力更生或者不需要写转换层，而是使用跟随者（conformist）模式；这样可以极大的简化集成。
# 14.8 模式: Anticorruption Layer
当正在构建的新系统与另一个系统的接口很大时，为了克服连接2个模型而带来的困难，新模型所表达的意图可能会被完全改变，最终导致它被修改得像是另一个系统的模型了，遗留系统的模型通常很弱，即使对于那些模型开发得很好的例外情况，它们可能也不符合当前项目的需要，集成遗留系统仍然具有很大的价值。
创建一个隔离层，以便根据客户自己的领域模型来为客户提供相关功能，这个层通过另一个系统现有接口与其进行对话，而只需对那个系统做出很少的修改，甚至无需修改，在内部，这个层在2个模型之间进行必要的双向转换。
- 设计Anticorruption Layer的接口，以service的形式提供，其实就是对另一个系统的抽象，抽象的定义要按照我们系统的模型来定义;
- 实现Anticorruption Layer，通过FACADE、ADAPTER与转换器以及底层的通信与传输实现Anticorruption Layer；对大而复杂，接口混乱的系统集成使用FACADE模式就能解决，ADAPTER用于转换2边的语义，每个Service都需要一个实现的接口的ADAPTER。
![Anticorruption Layer](14/Anticorruption-Layer.png)
子系统之间的通信可以在FACADE与子系统之间、ADPATER与FACADE之间、当前系统与ADAPTER之间，这取决于把Anticorruption Layer的组件放在哪，被集成的子系统如果可以，就进行可能的重构来方便集成；如果集成的内容比较多，那么当前系统可以选择做出一些改变，使接近外部系统的模型，或者极端情况选择跟随者模型。
# 14.9 模式：Separate Way
集成有时代价高昂，而有时获益很小。如果2个功能部分不互相调用对方的功能，或者对象并不交互，或者不共享数据，那么集成可能是没必要的。声明一个与其他上下文毫无关联的Bounded Context，使开发人员能够在这个范围内找到简单专用的解决方案。
# 14.10 模式: Open Host Service
当一个子系统必须与大量其他系统进行集成时，为每个集成都定制一个转换层可能会减慢团队的工作速度，需要维护的东西越来越多，而且修改的时候担心的事情也会越来越多，团队可能在做着同样的事情，如果一个子系统有某种内聚性，那么或许可以把它描述为一组Service，这组Service满足了其他子系统的公共需求，需要定义一个协议，把你的子系统作为一组Service供其他系统访问，开放这个协议，以便所有需要与你的子系统集成的人都可以使用它，当有新的集成需求时，就增强并扩展这个协议，但个别团队的特殊需求除外，满足这种特殊需求的方法是使用一次性的转换器来扩充协议，以便使共享协议简单且内聚。
# 14.11 模式：Published Language
2个限界上下文之间的模型转换需要一种公共的语言。一种解决办法时，把旧的模型转换为新的模型，因为总是认为新的模型是更好的。还有一种情况就是2种业务模型无法方便的转换，这时需要数据交换语言，这种数据交互语言已经充分的文档化，比如XML。
# 14.12 大象的统一
如果不需要集成，模型统不统一不重要，下图是6个盲人认识到的大象的模型
![6个盲人认识到的大象模型](14/elephant.png)
统一多个模型总是意味着创建一个新模型
![新的大象模型](14/new-elephant.png)
经过讨论，可能认识到他们正在对一个更大整体的不同部分进行描述与建模，部分-整体的集成只要完成各个部分的连接就可以了，如下图
![部分-整体的统一](14/entire-elephant.png)
持续精化以及新的需求会促成更深层次的模型理解。
![](14/more-elephant.png)
去除模型中那些偶然或不正确的方面并创建新的概念。
## 14.13 选择你的模型上下文策略



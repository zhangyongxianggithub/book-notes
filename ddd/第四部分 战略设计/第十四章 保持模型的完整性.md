模型最基本的要求是它应该保持内部一致，术语总具有相同的意义，不包含相互矛盾的规则，大型系统中无法保持这种统一，完全统一不可行，因为大型系统必须分模块开发。要保持模型关键部分的高度统一。
无法维护一个涵盖整个企业的统一模型，就要确定什么统一，什么不统一。统一的部分保持一致，不统一的部分不会混乱或者破坏模型。需要一种方式来标记不同模型之间的边界与关系，bounded context定义了每个模型的应用范围，context map定义了上下文与关系的总图，下图是模型完整性模式的导航图
![模型完整性导航图](14/model-navigator.png)
# 14.1 模式：bounded context
模型如果在不同的上下文中，就没有关联，是最简单的情况。但是想要复用模型的一部分工作时，会遇到问题比如，复用的边界在哪里？任何大型项目都会存在多个模型，而当基于不同模型的代码被组合到一起后，软件就会出现BUG、变得不可靠与难以理解，团队成员之间的沟通变得混乱，人们往往弄不清楚一个模型应该在哪个上下文中使用。一个模型只在一个上下文中使用，上下文可以是任何东西，比如代码、或者某个团队的工作，或者一次头脑风暴得到的模型的上下文就是头脑风暴讨论，模型只有在上下文中才有意义，上下文是模型的前提条件。明确的定义模型所应用的上下文也就是设置模型的边界，在这些边界中严格保持模型的一致性，而不要受到边界之外的问题的干扰与混淆。bounded context明确限定了模型的应用范围，以便让团队对什么应该保持一致以及上下文之间如何关联有一个明确和共同的理解，在context中，要保证模型在逻辑上统一，而不用考虑它是不是适用于边界之外的情况，在其他Context中，会使用其他模型。通过划定明确的边界，可以使模型保持纯粹，因而在它所适用的context中更有效，
# 14.2 Continuous Integration
当很多人在同一个Bounded Context中工作时，模型很容易发生分裂，团队越大，问题就越大，如果将系统分解为更小的Context，最终又难以保持集成度和一致性。有时开发人员没有完全理解其他人所创建的对象或者交互的意图，就对它进行了修改，使其失去了原来的作用，有时他们没有意识到他们正在开发的概念已经在模型的另一个部分中实现了，而导致了概念与行为重复，有时他们意识到了已经有了实现，却担心破坏现有功能而不敢去改动它，于是重复开发这些概念与功能。
Continuous Integration是指把一个上下文中的所有工作足够频繁地合并到一起，并使他们保持一致，以便当模型发生分裂时，可以迅速发现并纠正问题，有2个级别:
- 模型概念的集成;
- 实现的集成;
建立一个把所有代码与其他实现工件频繁的合并到一起的过程，并通过自动化测试来快速查明模型的分裂问题，严格坚持使用Ubiquitous Language，以便在不同人的头脑中演变出不同的概念时，使所有人对模型都能达成一致。
# 14.3 模式：Context Map
其他团队中的人员并不是十分清楚Context的边界，他们会不知不觉地做出一些更改，从而使边界变得迷糊，或者使互联变得复杂，当不同的上下文必须互相连接时，它们可能会相互重叠。限界上下文之间的代码重用是很危险的，应该避免，功能与数据的集成必须要通过转换去实现，通过定义不同上下文之间的关系，并在项目中创建一个所有模型上下文的全局视图，可以减少混乱。
识别在项目中起作用的每个模型，并定义其限界上下文，这包括非面向对象子系统的隐含模型，为每个限界上下文命名，把名称添加到Ubiquitous Language中，描述模型之间的连接点，明确所有通信需要的转换，并突出任何共享的内容。根据设计问题与项目组织问题的不同，限界上下文之间的关系有很多种形式，明确的Contextmap的画出是逐渐进行的，先找到一个比较接近的关系模式，找到那些特别明显违反模式的问题，修复，再观察，再修复。最终明确.
限界上下文应该有名称，以便可以讨论他们，这些名称应该被添加到团队的统一语言中，每个人都应该知道边界在哪里，应该能够分辨出任何代码段的Context，或任何情况的Context，比如通过Module的方式隔离Context，或者图、或者文本。
# 14.4 限界上下文之间的关系
模型之间的关系可以为组织开发工作设定目标并且可以为描述现有组织提供术语。
# 14.5 模式：Shared Kernel(共享内核)
![共享内核](14/shared-kernel.png)
当开发团队开发一些紧密相关的应用程序时，如果团队之间不进行协调，即使短时间内能够快速取得进展，但他们开发出的产品可能无法结合到一起，就是不方便集成，最后可能不得不耗费大量精力在转换层上，并且频繁的进行改动，不如一开始就使用Continuous Integration那么省心省力，同时也造成重复工作。从领域模型中选出2个团队都同意共享的一个子集，当然，除了这个模型子集以外，还包括与该模型部分相关的代码子集，或数据库设计的子集，这部分明确共享的内容具有特殊地位，一个团队在没有与另一个团队商量的情况下不应擅自更改它。
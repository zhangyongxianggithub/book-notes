每个对象都有生命周期，一些临时对象的生命周期因为比较短，关联少，所以不是很复杂，但是长生命周期的对象的状态关联比较多，需要仔细考虑以便满足model-driven design。
主要的挑战有2个:
- 在整个生命周期中维护完整性
- 防止模型陷入管理生命周期复杂性造成的困境当中。
3种模式解决这个问题
- AGGREGATE: 通过定义清晰的所属关系与边界避免混乱的模型关系实现模型的内聚;
- FACTORY: 创建重建复杂对象与AGGREGATE，封装内部结构;
- REPOSITORY: 查找与检索持久化对象并封装庞大的基础设施.
# 6.1 模式：AGGREGATE
在具有复杂关联的模型中，要想保证对象更改的一致性是很难的，不仅互不关联的对象需要遵守一些固定的规则，紧密关联的对象的也要遵守一些固定规则，过于谨慎的锁定机制会导致多个用户之间毫无意义的互相干扰，使系统不可用。这些问题的根源在于模型定义缺乏明确的边界，领域对象需要划分并确定从属关系。下面是一个划分边界的模式
- 首先，我们需要一个抽象来封装模型中的引用，AGGREGATE就是一组相关对象的集合，它是数据修改的单元，是一个相关关联的对象的整体，每个AGGREGATE都有一个root与boundary，boundary边界定义AGGREGATE内都有什么，边界也就是构成整个对象的具体的组件的对象或者模块等，root是对象整体，也就是一个ENTITY，root是AGGREGATE唯一允许外部对象保持对AGGREGATE引用的元素，就是对外只报漏整体对象，边界对象可以互相引用并且具有内部标识。一个典型的模型的例子是汽车，汽车是一个聚合根，如下图所示
![汽车作为聚合根](6/car-example.png)
固定规则：数据变化时，必须保持不变的一致性规则，AGGREGATE内部的对象之间就是固定规则关系，AGGREGATE内部的规则不一定非要每时每刻都要求对象符合，比如事务的中间，对象处于中间态，或者是异步更新等，但是在事务处理完成后，AGGREGATE内对象状态要符合固定规则。下入时car的固定规则
![car的固定规则](6/car-solid-rules.png)
为了实现AGGREGATE，所有的事务需要满足：
- 根具有全局标识，它最终负责检查固定规则;
- 根具有全局标识，边界内的ENTITY具有本地标识，这些标识只有在AGGREGATE内部才是唯一的。
- AGGREGATE外部的对象不能引用除root外的任何的内部对象，root可以boundary的引用传递给外部，但是只是临时使用，不能保持引用或者就是传递一个Value Object。
- 只有AGGREGATE的根才能直接通过数据库查询到，所有其他对象必须通过关联的遍历才能找到。
- 删除操作必须一次删除AGGREGATE边界内的所有对象;
- 当提交对AGGREGATE边界内部的任何对象的修改时，整个AGGREGATE内的所有的固定规则必须被满足.
root作为根，可以用来控制对边界内其他对象的所有访问，因为访问边界只能通过root，不能绕过root，这有利于确保AGGREGATE中的所有对象满足固定规则。
# 6.2 模式：FACTORY
对象承担很多职责，如果还负责自身的创建，则会指责过载，对象的创建与执行通常是分开的，就像汽车的装配与驾驶是分开的一样，2种操作放到一起是指责过载。
客户知道要完成的操作，并依靠领域对象执行必要的计算，如果将创建领域对象的职责交给客户，那么客户需要知道对象的内部结构与AGGREGATE的固定规则，结果就是领域对象的任何的修改，都要客户改动。重构变得困难。
对象的创建本身是一个主要操作，但是被创建的对象并不适合承担复杂的装配操作，客户负责会让客户的代码破坏装配对象与AGGREGATE的封装，导致客户与被创建对象产生过雨紧密的耦合。
复杂对象的创建是领域层的职责，这种职责不属于模型的对象，每种语言都提供了创建对象的机制，但还是需要更加抽象且不与其他对象发生耦合的构造机制。
![factory](6/factory.png)
FACTORY应该封装创建复杂对象与AGGREGATE的知识，它仅提供一个反映客户目标的接口，返回的是被创建对象的抽象视图。
应该将创建复杂对象的实例与呼和的职责交给一个单独的对象。
FACTORY的几种创建模式：
- factory method
- abstract factory
- builder
工厂需要满足2个基本需求：
- 每个创建方法都是原子的，被创建的对象的状态要满足固定规则，如果无法正确创建，需要抛出异常;
- 返回的结果应该是抽象的类型，不应该是具体类。
## 6.2.1 选择FACTORY及其应用位置
一般来说，FACTORY的作用是隐藏创建对象的细节，这些细节与AGGREGATE相关。
如果向一个AGGREGATE中添加元素，可以在root上创建FACTORY，把AGGREGATE的内部细节隐藏起来，root确保添加元素时的完整性。
![添加元素的例子](6/factory-add.png)
另一个例子是，当一个对象的创建主要使用另一个对象的数据时，可以在后者的对象上创建FACTORY，这样不必将后者的信息提取到其他地方，
![依赖创建](6/factory-dep.png)
FACTORY与被创建的对象时紧密耦合的，当有些细节需要隐藏时，必须创建一个FACTORY或者SERVICE；整个AGGREGATE通常由一个独立的FACTORY来创建，FACTORY负责把根的引用传递出去，如果AGGREGATE的内部的某个对象需要一个FACTORY，FACTORY要么建立在聚合根上，要么是独立的，如下图
![独立的聚合根](6/factory-duli.png)
### 6.2.2 有些情况下只需使用构造函数
使用简单的公共的构造函数的场景：
- 没有多态;
- 客户关系的是实现, 直接依赖实现;
- 客户可以访问对象的所有的属性;
- 构造不复杂;
- 公共构造函数是原子的，符合固定规则.
不要在构造函数中调用其他类的构造函数，这种装配使用工厂更合适；
### 6.2.3 接口的设计
FACTORY的方法签名满足的规则
- 每个操作都必须是原子的，我们必须在与FACTORY的一次交互中把创建对象所需要的所有的信息传给FACTORY，不符合规则的直接抛出异常或者返回null。
- FACTORY将会与参数发生耦合，参数最好是较低设计层的参数或者是模型中与创建对象密切相关的对象。
### 6.2.4 固定规则的相关逻辑应放到那里？
放到FACTORY中，不要放到FACTRORY METHOD中。
### 6.2.5 Entity Factory与Value Object Factory
一个可变一个不可变，Value Object Factory构造出来的对象就是最终的形势，Entity只要满足规定规则就行了，其他细节可以之后添加，
### 6.2.6 重建已存储的对象
重建的Factory与创建的Factory有2个不同
- 不重新分配标识ID，标识ID是参数的的一部分;
- 当固定规则不满足时，重建Factory需要通过某种策略修复不一致的情况。
![对象重建工厂](6/reconstruction-factory.png)
# 6.3 模式：REPOSITORY


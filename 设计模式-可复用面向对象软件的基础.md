# 1. 引言
设计可复用的面向对象软件比较困难，步骤：
- 找到相关的对象；
- 适当的粒度归类；
- 定义类的接口与继承层次；
- 建立对象之间的基本关系；
设计对手头的问题有针对性，对将来的问题与需求要有足够的通用性；一个设计在最终完成前需要数次修改。
设计模式可以复用成功的设计与体系结构，设计模式可以帮助设计者更快更好的完成系统设计。
## 1.1 什么是设计模式
Christopher Alexander: 每一个模式描述了一个在我们周围不断重复发生的问题以及该问题的解决方案的核心，可以一次又一次的使用方案而不必做重复的劳动。
一个模式的4个要素：
- 模式名：对模式的命名；
- 问题：描述了应该在何时使用模式；
- 解决方案：描述了设计的组成成分，它们之间的相互关系各自的职责与协作方式；
- 效果：描述了模式应用的效果以及使用模式应权衡的问题，对灵活性、扩充性、可移植性的影响。
## 1.2 Smalltalk MVC中的设计模式
MVC（model、view、control）三元组模式，通常用与书写视图界面类的程序；MVC通过建立订阅与通知（观察者模式）机制来分离视图与模型。
## 1.3 描述设计模式
描述的结构
- 模式名与分类；
- 意图：设计模式是做什么的？基本原理与意图是什么？它解决的是什么样的特定设计问题？
- 别名：模式的其他名称；
- 动机：一个简单的情景，说明一个设计问题以及如何用模式中的类、对象来解决该问题；
- 适用性：什么情况下，可以使用该设计模式？
- 结构：才有对象建模技术表示类的关系；
- 参与者：设计模式中的类、对象与它们各自的职责；
- 协作：模式的参与者怎么协作来实现职责；
- 效果：
- 实现：
- 代码实例：
- 已知应用；
- 相关模式：类似的模式的区别。
## 设计模式编目
23种设计模式与意图
- Abstract Factory：提供您一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类；
- Adapter: 将一个类的接口转换成客户希望的另外一个接口；
- Bridge：将抽象部分与实现部分分离，使它们都可以独立的变化；
- Builder：将复杂对象的构建与表示分离，使得构建过程可以创建不同的表示；
- Chain of Responsibility：解除请求的发送者与接受者之间的耦合，使多个对象都有机会处理这个请求，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它；
- Command：将请求封装为一个对象，从而可以用不同的请求对客户参数化，对请求排队或者记录请求日志，以及支持可取消的操作；
- Compsite：将对象组合成树形结构以表示“部分-整体”的层次结构，使得对单个对象与组合对象的使用具有一致性；
- Decorator：动态的给一个对象添加额外的职责，比生成子类更灵活；
- Facade：为系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得子系统更加容易使用；
- Factory Method：定义一个用于创建对相关的接口，让子类决定将哪个类实例化，使类的实例化延迟到子类中；
- Flyweight：运用共享技术有效的支持大量细粒度的对象；
- Interpreter：给定一个语言，定义它的文法的一种表示，定义一个解释器，该解释器使用该表示来解释语言中的句子；
- Iterator：提供一个方法顺序访问一个聚合对象中的元素，不需要曝漏该对象的内部表示；
- Mediator：
